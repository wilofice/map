<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Horizontal Mind Map</title>
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

        :root {
            --color-bg: #1a202c;
            --color-surface: #2d3748;
            --color-text: #e2e8f0;
            --color-text-muted: #a0aec0;
            --color-border: #4a5568;
            --color-primary: #4299e1;
            --color-primary-hover: #63b3ed;
            --color-secondary: #718096;
            --color-secondary-hover: #a0aec0;
            --color-success: #48bb78;
            --color-success-hover: #68d391;
            --color-line: #718096;
            
            /* VIBRANT Priority Colors */
            --priority-high-bg: rgba(252, 129, 129, 0.2);
            --priority-high-border: #fc8181;
            --priority-medium-bg: rgba(252, 211, 77, 0.2);
            --priority-medium-border: #fcd34d;
            --priority-low-bg: rgba(56, 189, 248, 0.2);
            --priority-low-border: #38bdf8;
            
            --sidebar-width: 280px;
        }

        @keyframes bounce-in-place {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        @keyframes color-flash {
            0%, 100% { background-color: var(--original-bg); }
            30% { background-color: var(--priority-high-bg); }
            60% { background-color: var(--priority-medium-bg); }
            90% { background-color: var(--priority-low-bg); }
        }

        @keyframes connector-color-cycle {
            0%, 100% { border-color: var(--priority-high-border); }
            33% { border-color: var(--priority-medium-border); }
            66% { border-color: var(--priority-low-border); }
        }

        @keyframes rotating-border {
            0% {
                background-position: 0% 50%;
            }
            100% {
                background-position: 100% 50%;
            }
        }

        html {
            background-color: var(--color-surface);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            color: var(--color-text);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            display: flex;
        }

        /* Sidebar Styles */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--color-bg);
            border-right: 1px solid var(--color-border);
            padding: 1.5rem;
            overflow-y: auto;
            flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease;
        }

        .sidebar.collapsed {
            width: 50px;
            padding: 1rem 0.5rem;
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .sidebar.collapsed h2 {
            display: none;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
        }

        .sidebar.collapsed .sidebar-header {
            justify-content: center;
            margin-bottom: 0;
        }

        .sidebar h2 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--color-text);
        }

        .sidebar-toggle {
            background: var(--color-secondary);
            color: var(--color-text);
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }

        .sidebar-toggle:hover {
            background: var(--color-secondary-hover);
        }

        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .file-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: var(--color-surface);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .file-item:hover {
            background: rgba(66, 153, 225, 0.1);
        }

        .file-item.active {
            background: var(--color-primary);
            color: var(--color-bg);
        }

        .file-icon {
            font-size: 0.9rem;
        }

        .new-file-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--color-success);
            color: var(--color-bg);
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 1.5rem;
            transition: background-color 0.2s;
        }

        .new-file-btn:hover {
            background: var(--color-success-hover);
        }

        /* Working Root Directory Styles */
        .working-root-section {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
        }

        .working-root-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--color-bg);
            border-radius: 6px;
            margin-bottom: 0.75rem;
            border: 1px solid var(--color-primary);
        }

        .working-root-path {
            color: var(--color-primary);
            font-weight: 500;
            flex: 1;
            font-family: monospace;
            font-size: 0.85rem;
            word-break: break-all;
        }

        /* Folder Navigation Styles */
        .folder-navigation {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
        }

        .current-folder {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--color-surface);
            border-radius: 6px;
            margin-bottom: 0.75rem;
        }

        .folder-icon {
            font-size: 1rem;
        }

        .folder-path {
            color: var(--color-text);
            font-weight: 500;
            flex: 1;
            font-family: monospace;
        }

        .folder-controls {
            display: flex;
            gap: 0.5rem;
        }

        .folder-btn {
            background: var(--color-secondary);
            color: var(--color-text);
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .folder-btn:hover {
            background: var(--color-secondary-hover);
        }

        .folder-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .folder-section {
            margin-bottom: 1.5rem;
        }

        .folder-section h3 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            color: var(--color-text-muted);
            font-weight: 500;
        }

        .folder-list {
            list-style: none;
            padding: 0;
            margin: 0 0 1rem 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .folder-item {
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.25rem;
            background: var(--color-surface);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .folder-item:hover {
            background: rgba(66, 153, 225, 0.1);
        }

        .folder-item.active {
            background: var(--color-primary);
            color: var(--color-bg);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--color-bg);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            border: 1px solid var(--color-border);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--color-border);
        }

        .modal-header h3 {
            margin: 0;
            color: var(--color-text);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.25rem;
        }

        .modal-close:hover {
            color: var(--color-text);
        }

        .modal-body {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .filesystem-nav {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
        }

        .current-path {
            font-family: monospace;
            color: var(--color-primary);
            margin-bottom: 0.75rem;
            word-break: break-all;
        }

        .fs-controls {
            display: flex;
            gap: 0.5rem;
        }

        .folder-btn.success {
            background: var(--color-success);
        }

        .folder-btn.success:hover {
            background: var(--color-success-hover);
        }

        .filesystem-folders h4 {
            color: var(--color-text);
            margin: 0 0 0.75rem 0;
        }

        .fs-folder-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--color-surface);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .fs-folder-item:hover {
            background: rgba(66, 153, 225, 0.1);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2rem;
            overflow: auto;
        }

        .container {
            background: transparent;
            padding: 0;
            text-align: left;
        }

        h1 {
            color: var(--color-text);
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .btn {
            background-color: var(--color-primary);
            color: #1a202c;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background-color: var(--color-primary-hover);
            box-shadow: 0 4px 10px rgba(66, 153, 225, 0.2);
        }

        .btn-secondary {
            background-color: var(--color-secondary);
        }
        .btn-secondary:hover {
            background-color: var(--color-secondary-hover);
            box-shadow: 0 4px 10px rgba(113, 128, 150, 0.2);
        }
        
        .btn-success {
            background-color: var(--color-success);
        }
        .btn-success:hover {
            background-color: var(--color-success-hover);
            box-shadow: 0 4px 10px rgba(72, 187, 120, 0.2);
        }

        /* HORIZONTAL Mind Map Styling - Exact copy from original */
        .mind-map-container {
            padding-top: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .node {
            display: flex;
            align-items: center;
            position: relative;
            padding: 1rem 0 1rem 3rem;
        }

        /* Root Node Styling */
        .mind-map-container > .node {
            padding-left: 0;
            margin: 0;
        }

        .node-wrapper {
            display: inline-flex;
            flex-direction: column;
            align-items: stretch;
        }
        
        .mind-map-container > .node::before,
        .mind-map-container > .node::after {
            display: none;
        }
        
        .node-content {
            border: 1px solid;
            border-radius: 8px;
            padding: 0.6rem 1rem;
            font-weight: 500;
            position: relative;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-shrink: 0;
        }
        
        .node-content:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .node-title {
            outline: none;
            white-space: nowrap;
        }
        
        .node-title[contenteditable="true"] {
            background-color: var(--color-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.4);
        }

        .node-toggle {
            font-weight: bold;
            line-height: 1;
            width: 1rem;
            text-align: center;
            cursor: pointer;
            user-select: none;
            color: var(--color-primary);
            font-size: 1.2rem;
        }

        /* Priority Colors with Gradients */
        .priority-high > .node-wrapper > .node-content { 
            background: linear-gradient(135deg, 
                rgba(252, 129, 129, 0.3) 0%, 
                rgba(239, 68, 68, 0.15) 50%,
                rgba(252, 129, 129, 0.25) 100%);
            border-color: var(--priority-high-border);
        }
        .priority-medium > .node-wrapper > .node-content { 
            background: linear-gradient(135deg, 
                rgba(252, 211, 77, 0.3) 0%, 
                rgba(245, 158, 11, 0.15) 50%,
                rgba(252, 211, 77, 0.25) 100%);
            border-color: var(--priority-medium-border);
        }
        .priority-low > .node-wrapper > .node-content { 
            background: linear-gradient(135deg, 
                rgba(56, 189, 248, 0.3) 0%, 
                rgba(14, 165, 233, 0.15) 50%,
                rgba(56, 189, 248, 0.25) 100%);
            border-color: var(--priority-low-border);
        }

        /* Apply bounce to all nodes when flash is active */
        .flash-active .node-wrapper {
            animation: bounce-in-place 2s infinite ease-in-out;
        }
        
        /* Rotating border for in-progress nodes */
        .status-in-progress > .node-wrapper > .node-content {
            position: relative;
            overflow: visible;
        }
        
        .status-in-progress > .node-wrapper > .node-content::before {
            content: "";
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 10px;
            background: linear-gradient(90deg, 
                rgba(252, 129, 129, 0.4) 0%, 
                rgba(252, 211, 77, 0.4) 33%, 
                rgba(56, 189, 248, 0.4) 66%, 
                rgba(252, 129, 129, 0.4) 100%);
            background-size: 300% 100%;
            z-index: -1;
            animation: rotating-border 3s linear infinite;
            opacity: 0;
        }
        
        .flash-active .status-in-progress > .node-wrapper > .node-content::before {
            opacity: 0.7;
        }
        
        .status-in-progress > .node-wrapper > .node-content::after {
            content: "";
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border-radius: 9px;
            background: inherit;
            z-index: -1;
        }
        
        .status-completed > .node-wrapper > .node-content {
            opacity: 0.8;
            background: linear-gradient(135deg, 
                rgba(113, 128, 150, 0.4) 0%, 
                rgba(71, 85, 105, 0.25) 50%,
                rgba(45, 55, 72, 0.35) 100%) !important;
            border-color: var(--color-secondary) !important;
        }
        .status-completed .node-title {
            text-decoration: line-through;
            opacity: 0.8;
        }

        /* Corrected Connector Lines - Exact copy from original */
        .node-parent {
            position: relative;
            padding-left: 3rem;
        }
        
        .node-parent > .node {
            padding: 1rem 0 1rem 3rem;
        }

        /* Draws the horizontal line */
        .node::after {
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            width: 1.5rem;
            height: 0;
            border-top: 3px solid var(--color-line);
        }

        /* Draws the vertical line segment */
        .node::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0;
            border-left: 3px solid var(--color-line);
        }
        
        /* Line Animation Setup */
        .lines-animated .node::before, .lines-animated .node::after {
            animation: connector-color-cycle 4s infinite linear;
        }

        /* Start the vertical line halfway down for the first child */
        .node-parent > .node:first-child::before {
            top: 50%;
        }

        /* End the vertical line halfway down for the last child */
        .node-parent > .node:last-child::before {
            bottom: 50%;
        }

        /* A single child only needs a horizontal line, no vertical part */
        .node-parent > .node:only-child::before {
            display: none;
        }

        .node-parent.collapsed {
            display: none;
        }
        
        /* Icons */
        .node-icon {
            cursor: pointer;
            color: var(--color-text-muted);
            font-size: 1rem;
            transition: color 0.2s, opacity 0.2s;
            opacity: 0;
        }
        .node-icon:hover { color: var(--color-text); }
        
        .icon-status { 
            font-size: 1.2rem;
            opacity: 1; /* Status icon always visible */
        }
        
        /* Show icons on hover */
        .node-content:hover .node-icon {
            opacity: 1;
        }
        
        .node-content:hover .icon-status {
            opacity: 1;
        }
        
        /* Comment */
        .node-comment {
            background: var(--color-bg);
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--color-text-muted);
            border: 1px solid var(--color-border);
            display: none;
            width: auto;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            box-sizing: border-box;
        }
        .node-comment[contenteditable="true"] {
             background: #1a202c;
             box-shadow: inset 0 1px 2px rgba(0,0,0,0.4);
             outline: 2px solid var(--color-primary);
        }
        
        .has-comment .icon-comment {
            color: var(--color-primary);
        }

        /* Code Block Styles */
        .node-code {
            background: #2d2d2d;
            border-radius: 6px;
            padding: 1rem;
            margin-top: 0.5rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            display: none;
            width: auto;
            max-width: 600px;
            overflow-x: auto;
            position: relative;
        }

        .node-code pre {
            margin: 0;
            overflow-x: auto;
        }

        .node-code pre code {
            font-family: inherit;
            font-size: inherit;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .code-language {
            color: var(--color-primary);
            font-weight: 500;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .copy-btn {
            background: var(--color-secondary);
            color: var(--color-text);
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .copy-btn:hover {
            background: var(--color-secondary-hover);
        }

        .copy-btn.copied {
            background: var(--color-success);
        }

        /* Task Prompt Styles */
        .node-task-prompt {
            background: linear-gradient(135deg, 
                rgba(147, 51, 234, 0.1) 0%, 
                rgba(79, 70, 229, 0.1) 100%);
            border: 1px solid rgba(147, 51, 234, 0.3);
            border-radius: 6px;
            padding: 1rem;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--color-text);
            display: none;
            width: auto;
            position: relative;
        }

        .task-prompt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(147, 51, 234, 0.2);
        }

        .task-prompt-label {
            color: #a78bfa;
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-prompt-content {
            white-space: pre-wrap;
            line-height: 1.6;
        }

        /* CLI Command Styles */
        .node-cli-command {
            background: #1a1a1a;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 1rem;
            margin-top: 0.5rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            color: #22c55e;
            display: none;
            width: auto;
            position: relative;
        }

        .cli-command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(34, 197, 94, 0.2);
        }

        .cli-command-label {
            color: #22c55e;
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cli-command-content {
            white-space: pre-wrap;
            line-height: 1.4;
        }

        /* Icon indicators for new elements */
        .has-code .icon-code {
            color: var(--color-primary);
        }

        .has-task-prompt .icon-task {
            color: #a78bfa;
        }

        .has-cli-command .icon-cli {
            color: #22c55e;
        }

        /* Dates & Days Spent */
        .node-dates {
            display: none;
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            background-color: var(--color-bg);
            border-radius: 6px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            white-space: nowrap;
        }
        .date-value {
            font-weight: 500;
            color: var(--color-text);
        }
        .date-value[contenteditable="true"] {
             background: var(--color-surface);
             padding: 0.1rem 0.3rem;
             border-radius: 4px;
             box-shadow: inset 0 1px 2px rgba(0,0,0,0.4);
             outline: 2px solid var(--color-primary);
        }
        .has-dates .icon-date {
            color: var(--color-primary);
        }

        .days-spent-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .days-spent-btn {
            background-color: var(--color-border);
            color: var(--color-text);
            border: none;
            border-radius: 50%;
            width: 1.25rem;
            height: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: background-color 0.2s;
        }
        .days-spent-btn:hover {
            background-color: var(--color-primary);
            color: var(--color-bg);
        }
        .days-spent-value {
            font-weight: 600;
            min-width: 1rem;
            text-align: center;
        }

        /* Hides the add button when toggled */
        .add-hidden .icon-add {
            display: none;
        }

        .import-indicator {
            font-size: 0.8rem;
            padding: 0.2rem 0.4rem;
            background: rgba(66, 153, 225, 0.2);
            border-radius: 4px;
            color: var(--color-primary);
            margin-left: 0.5rem;
        }

        /* Context menu */
        .context-menu {
            position: fixed;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background: var(--color-surface);
        }

        /* Save indicator */
        .save-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--color-success);
            color: var(--color-bg);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-weight: 500;
            z-index: 1000;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--color-text-muted);
        }

        .empty-state h3 {
            color: var(--color-text);
            margin-bottom: 1rem;
        }

        .error {
            color: #fc8181;
            padding: 1rem;
            background: rgba(252, 129, 129, 0.1);
            border-radius: 6px;
            margin: 1rem 0;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--color-text-muted);
        }

        /* Kanban Board Styles */
        .board-container {
            padding: 2rem 0;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .board-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--color-border);
        }

        .board-header h3 {
            margin: 0;
            color: var(--color-text);
            font-size: 1.5rem;
            font-weight: 600;
        }

        .board-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 2rem;
            min-height: 500px;
        }

        .board-column {
            background: var(--color-bg-secondary);
            border-radius: 12px;
            padding: 1rem;
            border: 2px solid var(--color-border);
        }

        .column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--color-border);
        }

        .column-header h4 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--color-text);
        }

        .task-count {
            background: var(--color-primary);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 1.5rem;
            text-align: center;
        }

        .column-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 400px;
        }

        .task-card {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .task-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            border-color: var(--color-primary);
            background: var(--color-bg);
        }

        .task-card.priority-high {
            border-left: 4px solid #ef4444;
        }

        .task-card.priority-medium {
            border-left: 4px solid #f59e0b;
        }

        .task-card.priority-low {
            border-left: 4px solid #10b981;
        }

        .task-title {
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            line-height: 1.3;
        }

        .task-content {
            color: var(--color-text-muted);
            font-size: 0.85rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }

        .task-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--color-text-muted);
            margin-top: 0.5rem;
        }

        .task-dates {
            display: flex;
            gap: 0.5rem;
        }

        .task-priority {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .task-priority.high {
            background: #fef2f2;
            color: #ef4444;
        }

        .task-priority.medium {
            background: #fefbf2;
            color: #f59e0b;
        }

        .task-priority.low {
            background: #f0fdf4;
            color: #10b981;
        }

        .empty-column {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            border: 2px dashed var(--color-border);
            border-radius: 8px;
            margin: 1rem 0;
        }

        /* Responsive design for board */
        @media (max-width: 1200px) {
            .board-columns {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .board-container {
                padding: 1rem 0;
            }
            
            .task-card {
                padding: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>üìÅ Project Files</h2>
            <button class="sidebar-toggle" id="sidebarToggle" title="Toggle Sidebar">‚Äπ</button>
        </div>
        
        <div class="sidebar-content">
            <!-- Working Root Directory -->
            <div class="working-root-section">
                <div class="working-root-display">
                    <span class="folder-icon">üè†</span>
                    <span class="working-root-path" id="workingRootPath">Loading...</span>
                </div>
                <button class="folder-btn" id="changeRootBtn" title="Change working root directory">üìÇ Change Root</button>
            </div>
            
            <!-- Folder Navigation -->
            <div class="folder-navigation">
                <div class="current-folder" id="currentFolder">
                    <span class="folder-icon">üìÇ</span>
                    <span class="folder-path">.</span>
                </div>
                <div class="folder-controls">
                    <button class="folder-btn" id="parentFolderBtn" title="Go to parent folder">‚Üë Parent</button>
                </div>
            </div>
            
            <!-- Folder List -->
            <div class="folder-section">
                <h3>üìÇ Folders</h3>
                <ul class="folder-list" id="folderList">
                    <li class="loading">Loading folders...</li>
                </ul>
            </div>
            
            <button class="new-file-btn" id="newFileBtn">+ New Mind Map</button>
            <ul class="file-list" id="fileList">
                <li class="loading">Loading files...</li>
            </ul>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <h1>üß† Modular Horizontal Mind Map</h1>
            
            <div class="controls" id="controls" style="display: none;">
                <button class="btn btn-success" id="saveBtn">üíæ <span class="btn-text">Save All Changes</span></button>
                <button class="btn btn-secondary" id="toggleCommentsBtn">üí¨ <span class="btn-text">Show Comments</span></button>
                <button class="btn btn-secondary" id="toggleDatesBtn">üìÖ <span class="btn-text">Show Dates</span></button>
                <button class="btn btn-secondary" id="toggleAddBtn">‚ûï <span class="btn-text">Hide Add Buttons</span></button>
                <button class="btn btn-secondary" id="toggleAllBtn">üìÇ <span class="btn-text">Toggle All</span></button>
                <button class="btn" id="toggleFlashBtn">‚ú® <span class="btn-text">Start Flash</span></button>
                <button class="btn" id="toggleAnimateLinesBtn">„Ä∞Ô∏è <span class="btn-text">Animate Lines</span></button>
                <button class="btn btn-info" id="toggleViewBtn">üìã <span class="btn-text">Board View</span></button>
                <button class="btn" id="cleanupBtn" style="background: #f59e0b; color: white;">üîß <span class="btn-text">Clean up IDs</span></button>
            </div>

            <div class="mind-map-container" id="mindMapContainer">
                <div class="empty-state">
                    <h3>Welcome to Modular Horizontal Mind Map</h3>
                    <p>Select a file from the sidebar to begin, or create a new mind map.</p>
                </div>
            </div>

            <!-- Kanban Board View -->
            <div class="board-container" id="boardContainer" style="display: none;">
                <div class="board-header">
                    <h3>üìã Project Board - <span id="boardTitle">Project</span></h3>
                </div>
                <div class="board-columns">
                    <div class="board-column" id="todoColumn">
                        <div class="column-header">
                            <h4>üìù To Do</h4>
                            <span class="task-count" id="todoCount">0</span>
                        </div>
                        <div class="column-content" id="todoCards">
                            <!-- Cards will be dynamically populated -->
                        </div>
                    </div>
                    
                    <div class="board-column" id="inProgressColumn">
                        <div class="column-header">
                            <h4>‚ö° In Progress</h4>
                            <span class="task-count" id="inProgressCount">0</span>
                        </div>
                        <div class="column-content" id="inProgressCards">
                            <!-- Cards will be dynamically populated -->
                        </div>
                    </div>
                    
                    <div class="board-column" id="doneColumn">
                        <div class="column-header">
                            <h4>‚úÖ Done</h4>
                            <span class="task-count" id="doneCount">0</span>
                        </div>
                        <div class="column-content" id="doneCards">
                            <!-- Cards will be dynamically populated -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="save-indicator" id="saveIndicator">‚úì Saved</div>

    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-priority="high">üî¥ High Priority</div>
        <div class="context-menu-item" data-priority="medium">üü° Medium Priority</div>
        <div class="context-menu-item" data-priority="low">üü¢ Low Priority</div>
    </div>

    <script>
        // Dynamic API base URL detection with fallback mechanism
        let API_BASE = null;
        let currentApiBaseIndex = 0;
        
        const getApiBaseCandidates = () => {
            const protocol = window.location.protocol;
            const hostname = window.location.hostname;
            const currentPort = window.location.port;
            
            const candidates = [
                `${protocol}//${hostname}:3000/api`, // Default development port
                `${protocol}//${hostname}:8000/api`, // Alternative port
                `${protocol}//${hostname}:8080/api`, // Alternative port
            ];
            
            // If we have a current port, also try port+1 and the same port
            if (currentPort) {
                candidates.unshift(`${protocol}//${hostname}:${parseInt(currentPort) + 1}/api`);
                candidates.unshift(`${protocol}//${hostname}:${currentPort}/api`);
            }
            
            return [...new Set(candidates)]; // Remove duplicates
        };
        
        const API_CANDIDATES = getApiBaseCandidates();
        
        // Function to test API connectivity
        async function testApiConnection(apiBase) {
            try {
                const response = await fetch(`${apiBase}/files`, { 
                    method: 'GET',
                    timeout: 2000 // 2 second timeout
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }
        
        // Function to find working API base
        async function findWorkingApiBase() {
            for (let i = 0; i < API_CANDIDATES.length; i++) {
                const candidate = API_CANDIDATES[i];
                console.log(`Testing API connection to: ${candidate}`);
                
                if (await testApiConnection(candidate)) {
                    console.log(`‚úÖ API server found at: ${candidate}`);
                    API_BASE = candidate;
                    currentApiBaseIndex = i;
                    return candidate;
                }
            }
            
            // If no API found, use the first candidate as fallback
            console.warn('‚ö†Ô∏è No working API server found, using default:', API_CANDIDATES[0]);
            API_BASE = API_CANDIDATES[0];
            currentApiBaseIndex = 0;
            return API_BASE;
        }
        
        // Function to retry with next API candidate on error
        async function retryWithNextApi() {
            if (currentApiBaseIndex < API_CANDIDATES.length - 1) {
                currentApiBaseIndex++;
                API_BASE = API_CANDIDATES[currentApiBaseIndex];
                console.log(`üîÑ Retrying with API: ${API_BASE}`);
                return true;
            }
            return false;
        }
        
        // Enhanced fetch with automatic API fallback
        async function fetchWithFallback(endpoint, options = {}) {
            let lastError = null;
            
            for (let attempt = 0; attempt < API_CANDIDATES.length; attempt++) {
                try {
                    const response = await fetch(`${API_BASE}${endpoint}`, options);
                    if (response.ok) {
                        return response;
                    }
                    lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
                } catch (error) {
                    lastError = error;
                    console.warn(`‚ùå API call failed to ${API_BASE}${endpoint}:`, error.message);
                    
                    // Try next API candidate
                    if (await retryWithNextApi()) {
                        continue;
                    }
                }
                break;
            }
            
            throw lastError || new Error('All API endpoints failed');
        }
        
        let currentFile = null;
        let currentFolder = '.';
        let xmlData = null;
        let autoSaveTimeout = null;
        let lastCheckTime = Date.now();
        let syncCheckInterval;
        
        // UI state
        let areCommentsVisible = false;
        let areDatesVisible = false;
        let areAddButtonsVisible = true;
        let areFlashesVisible = true;  // Default to true
        let areLinesAnimated = true;    // Default to true

        // Initialize application
        async function init() {
            // First, find a working API server
            await findWorkingApiBase();
            
            await loadWorkingRoot();
            await loadFolderList();
            await loadFileList();
            setupEventListeners();
        }

        // Load current working root directory
        async function loadWorkingRoot() {
            try {
                const response = await fetch(`${API_BASE}/working-root`);
                const data = await response.json();
                document.getElementById('workingRootPath').textContent = data.workingRoot;
                console.log('Working root:', data.workingRoot);
            } catch (error) {
                console.error('Failed to load working root:', error);
                document.getElementById('workingRootPath').textContent = 'Error loading';
            }
        }

        // Show filesystem browser modal
        async function showFilesystemBrowser() {
            try {
                const response = await fetch(`${API_BASE}/filesystem-browse`);
                const data = await response.json();
                
                let modalHTML = `
                    <div class="modal-overlay" id="filesystemModal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>üìÇ Select Working Directory</h3>
                                <button class="modal-close" onclick="closeFilesystemBrowser()">‚úï</button>
                            </div>
                            <div class="modal-body">
                                <div class="filesystem-nav">
                                    <div class="current-path" id="fsCurrentPath">Select a location</div>
                                    <div class="fs-controls">
                                        <button class="folder-btn" id="fsParentBtn" style="display:none;">‚Üë Parent</button>
                                        <button class="folder-btn success" id="fsSelectBtn" style="display:none;">‚úì Select This Folder</button>
                                    </div>
                                </div>
                                <div class="filesystem-folders" id="fsFolders">
                `;
                
                if (data.commonLocations) {
                    modalHTML += '<h4>Common Locations:</h4>';
                    data.commonLocations.forEach(location => {
                        modalHTML += `<div class="fs-folder-item" data-path="${location.path}">${location.name}</div>`;
                    });
                }
                
                modalHTML += `
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                setupFilesystemBrowserEvents();
            } catch (error) {
                console.error('Failed to load filesystem browser:', error);
                alert('Failed to load filesystem browser');
            }
        }

        // Load folder contents in filesystem browser
        async function loadFilesystemFolder(folderPath) {
            try {
                const response = await fetch(`${API_BASE}/filesystem-browse?path=${encodeURIComponent(folderPath)}`);
                const data = await response.json();
                
                document.getElementById('fsCurrentPath').textContent = data.currentPath;
                
                const parentBtn = document.getElementById('fsParentBtn');
                const selectBtn = document.getElementById('fsSelectBtn');
                
                if (data.parentPath) {
                    parentBtn.style.display = 'inline-block';
                    parentBtn.onclick = () => loadFilesystemFolder(data.parentPath);
                } else {
                    parentBtn.style.display = 'none';
                }
                
                selectBtn.style.display = 'inline-block';
                selectBtn.onclick = () => selectWorkingRoot(data.currentPath);
                
                const foldersDiv = document.getElementById('fsFolders');
                foldersDiv.innerHTML = '';
                
                if (data.folders.length === 0) {
                    foldersDiv.innerHTML = '<div class="empty-state">No subfolders found</div>';
                } else {
                    data.folders.forEach(folder => {
                        const folderElement = document.createElement('div');
                        folderElement.className = 'fs-folder-item';
                        folderElement.dataset.path = folder.path;
                        folderElement.innerHTML = `üìÇ ${folder.name}`;
                        foldersDiv.appendChild(folderElement);
                    });
                }
                
                setupFilesystemBrowserEvents();
            } catch (error) {
                console.error('Failed to load filesystem folder:', error);
                document.getElementById('fsFolders').innerHTML = '<div class="error">Failed to load folder contents</div>';
            }
        }

        // Setup events for filesystem browser
        function setupFilesystemBrowserEvents() {
            document.querySelectorAll('.fs-folder-item').forEach(item => {
                item.onclick = () => loadFilesystemFolder(item.dataset.path);
            });
        }

        // Select working root directory
        async function selectWorkingRoot(rootPath) {
            try {
                const response = await fetch(`${API_BASE}/working-root`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: rootPath })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    closeFilesystemBrowser();
                    await loadWorkingRoot();
                    
                    // Reset to root folder and refresh
                    currentFolder = '.';
                    await loadFolderList();
                    await loadFileList();
                    
                    // Clear current file
                    currentFile = null;
                    document.getElementById('controls').style.display = 'none';
                    document.getElementById('mindMapContainer').innerHTML = `
                        <div class="empty-state">
                            <h3>Working directory changed!</h3>
                            <p>Now browsing: ${rootPath}</p>
                            <p>Select a file from the sidebar to begin.</p>
                        </div>
                    `;
                    
                    alert(`Working directory changed to: ${rootPath}`);
                } else {
                    alert('Failed to change working directory: ' + result.error);
                }
            } catch (error) {
                console.error('Failed to select working root:', error);
                alert('Failed to change working directory');
            }
        }

        // Close filesystem browser
        function closeFilesystemBrowser() {
            const modal = document.getElementById('filesystemModal');
            if (modal) {
                modal.remove();
            }
        }

        // Load list of folders in current directory
        async function loadFolderList() {
            console.log('Loading folder list from:', `${API_BASE}/folders?path=${encodeURIComponent(currentFolder)}`);
            try {
                const response = await fetch(`${API_BASE}/folders?path=${encodeURIComponent(currentFolder)}`);
                const data = await response.json();
                console.log('Folders received:', data);
                
                // Update current folder display
                document.querySelector('.folder-path').textContent = data.currentPath;
                
                // Update parent button
                const parentBtn = document.getElementById('parentFolderBtn');
                if (data.parentPath !== null) {
                    parentBtn.disabled = false;
                    parentBtn.onclick = () => changeFolder(data.parentPath);
                } else {
                    parentBtn.disabled = true;
                }
                
                // Update folder list
                const folderList = document.getElementById('folderList');
                if (data.folders.length === 0) {
                    folderList.innerHTML = '<li class="empty-state">No subfolders found</li>';
                } else {
                    folderList.innerHTML = data.folders.map(folder => `
                        <li class="folder-item" data-folder="${folder.path}">
                            <span class="folder-icon">üìÇ</span>
                            <span>${folder.name}</span>
                        </li>
                    `).join('');
                }
            } catch (error) {
                console.error('Failed to load folders:', error);
                document.getElementById('folderList').innerHTML = 
                    '<li class="error">Failed to load folders</li>';
            }
        }

        // Load list of XML files in current folder
        async function loadFileList() {
            console.log('Loading file list from:', `${API_BASE}/files/${currentFolder}`);
            try {
                const url = currentFolder === '.' ? 
                    `${API_BASE}/files` : 
                    `${API_BASE}/files/${encodeURIComponent(currentFolder)}`;
                const response = await fetch(url);
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Files received:', data);
                
                // Handle both old format (array) and new format (object with files property)
                const files = Array.isArray(data) ? data : (data.files || []);
                
                const fileList = document.getElementById('fileList');
                if (files.length === 0) {
                    fileList.innerHTML = '<li class="empty-state">No XML files found</li>';
                } else {
                    fileList.innerHTML = files.map(file => `
                        <li class="file-item" data-file="${file}">
                            <span class="file-icon">üìÑ</span>
                            <span>${file}</span>
                        </li>
                    `).join('');
                }
            } catch (error) {
                console.error('Failed to load files:', error);
                document.getElementById('fileList').innerHTML = 
                    '<li class="error">Failed to connect to server. Make sure the server is running.</li>';
            }
        }

        // Change current folder and refresh views
        async function changeFolder(newFolder) {
            currentFolder = newFolder;
            console.log('Changing to folder:', currentFolder);
            
            // Clear current file selection since we're switching folders
            currentFile = null;
            document.getElementById('controls').style.display = 'none';
            document.getElementById('mindMapContainer').innerHTML = `
                <div class="empty-state">
                    <h3>Welcome to Modular Horizontal Mind Map</h3>
                    <p>Select a file from the sidebar to begin, or create a new mind map.</p>
                </div>
            `;
            
            // Refresh both folder and file lists
            await loadFolderList();
            await loadFileList();
        }

        // Load and display a mind map file
        async function loadFile(filename) {
            try {
                const url = currentFolder === '.' ? 
                    `${API_BASE}/load/${filename}` : 
                    `${API_BASE}/load/${filename}?folder=${encodeURIComponent(currentFolder)}`;
                const response = await fetch(url);
                const data = await response.json();
                
                currentFile = filename;
                xmlData = data.data;
                
                // Update UI
                document.querySelectorAll('.file-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.file === filename);
                });
                
                // Update title
                const title = filename.replace(/\.xml$/i, '');
                document.querySelector('h1').textContent = title;
                
                document.getElementById('controls').style.display = 'flex';
                renderMindMap();
                
                // Apply default animations state
                if (areFlashesVisible) {
                    document.body.classList.add('flash-active');
                }
                if (areLinesAnimated) {
                    document.body.classList.add('lines-animated');
                }
                updateToggleFlashButton();
                updateToggleAnimateLinesButton();
                
                // Start sync checking for this file
                lastCheckTime = Date.now();
                startSyncCheck();
            } catch (error) {
                console.error('Failed to load file:', error);
                document.getElementById('mindMapContainer').innerHTML = 
                    '<div class="error">Failed to load file. Please try again.</div>';
                stopSyncCheck(); // Stop sync checking on error
            }
        }

        // Render the mind map with horizontal layout
        function renderMindMap() {
            const container = document.getElementById('mindMapContainer');
            container.innerHTML = '';
            
            if (!xmlData || !xmlData.project_plan || !xmlData.project_plan.node) {
                container.innerHTML = '<div class="empty-state">No data to display</div>';
                return;
            }
            
            // Ensure nodes is an array
            const nodes = Array.isArray(xmlData.project_plan.node) 
                ? xmlData.project_plan.node 
                : [xmlData.project_plan.node];
            
            nodes.forEach(nodeData => {
                renderNode(nodeData, container);
            });
        }

        // Render a single node with exact original structure
        function renderNode(nodeData, parentElement) {
            const priority = nodeData.$ && nodeData.$.priority || 'medium';
            const status = nodeData.$ && nodeData.$.status || 'pending';
            let nodeId = nodeData.$ && nodeData.$.id;
            
            // Fix undefined or missing IDs
            if (!nodeId || nodeId === 'undefined') {
                nodeId = generateId();
                if (nodeData.$) {
                    nodeData.$.id = nodeId;
                }
                console.warn('Fixed undefined node ID in renderNode, generated:', nodeId);
            }
            
            const title = nodeData.$ && nodeData.$.title || 'New Node';
            const startDate = nodeData.$ && nodeData.$.startDate || '';
            const endDate = nodeData.$ && nodeData.$.endDate || '';
            const daysSpent = nodeData.$ && nodeData.$.daysSpent || '0';
            
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'node';
            nodeDiv.dataset.priority = priority;
            nodeDiv.dataset.status = status;
            nodeDiv.dataset.id = nodeId;
            
            // Set data attributes for save-split functionality
            if (nodeData.$ && nodeData.$.dataSource) {
                nodeDiv.dataset.dataSource = nodeData.$.dataSource;
            }
            if (nodeData.$ && nodeData.$.dataImported) {
                nodeDiv.dataset.dataImported = nodeData.$.dataImported;
            }
            if (nodeData.$ && nodeData.$.dataImportFrom) {
                nodeDiv.dataset.dataImportFrom = nodeData.$.dataImportFrom;
            }
            
            nodeDiv.classList.add(`priority-${priority}`);
            nodeDiv.classList.add(`status-${status}`);
            
            const nodeWrapper = document.createElement('div');
            nodeWrapper.className = 'node-wrapper';
            nodeWrapper.dataset.id = nodeId;
            
            const nodeContentDiv = document.createElement('div');
            nodeContentDiv.className = 'node-content';
            
            const toggleSpan = document.createElement('span');
            toggleSpan.className = 'node-toggle';
            toggleSpan.textContent = '‚Äì';
            
            const statusIcon = document.createElement('span');
            statusIcon.className = 'node-icon icon-status';
            if (status === 'pending') statusIcon.innerHTML = 'üî≤';
            else if (status === 'in-progress') statusIcon.innerHTML = 'üü°';
            else if (status === 'completed') statusIcon.innerHTML = '‚úÖ';
            statusIcon.title = "Cycle Status";
            
            const titleSpan = document.createElement('span');
            titleSpan.className = 'node-title';
            titleSpan.textContent = title;
            
            // Import indicator
            if (nodeData.$ && nodeData.$.dataImported === 'true') {
                const indicator = document.createElement('span');
                indicator.className = 'import-indicator';
                indicator.textContent = 'üîó ' + nodeData.$.dataImportFrom;
                indicator.title = 'Imported from: ' + nodeData.$.dataImportFrom;
                titleSpan.appendChild(indicator);
            }
            
            const dateIcon = document.createElement('span');
            dateIcon.className = 'node-icon icon-date';
            dateIcon.innerHTML = 'üìÖ';
            dateIcon.title = 'Toggle Dates';
            
            const commentIcon = document.createElement('span');
            commentIcon.className = 'node-icon icon-comment';
            commentIcon.innerHTML = 'üí¨';
            commentIcon.title = "Toggle Comment";
            
            const codeIcon = document.createElement('span');
            codeIcon.className = 'node-icon icon-code';
            codeIcon.innerHTML = 'üíª';
            codeIcon.title = "Toggle Code";
            
            const taskIcon = document.createElement('span');
            taskIcon.className = 'node-icon icon-task';
            taskIcon.innerHTML = 'ü§ñ';
            taskIcon.title = "Toggle Task Prompt";
            
            const cliIcon = document.createElement('span');
            cliIcon.className = 'node-icon icon-cli';
            cliIcon.innerHTML = '‚ö°';
            cliIcon.title = "Toggle CLI Command";
            
            const addIcon = document.createElement('span');
            addIcon.className = 'node-icon icon-add';
            addIcon.innerHTML = '‚ûï';
            addIcon.title = "Add Child Node";
            
            const deleteIcon = document.createElement('span');
            deleteIcon.className = 'node-icon icon-delete';
            deleteIcon.innerHTML = 'üóëÔ∏è';
            deleteIcon.title = "Delete Node";
            
            nodeContentDiv.append(toggleSpan, statusIcon, titleSpan, dateIcon, commentIcon, codeIcon, taskIcon, cliIcon, addIcon, deleteIcon);
            nodeWrapper.appendChild(nodeContentDiv);
            
            // Dates Div
            const datesDiv = document.createElement('div');
            datesDiv.className = 'node-dates';
            
            const dateRangeSpan = document.createElement('span');
            const dateSeparator = startDate && endDate ? ' : ' : '';
            dateRangeSpan.innerHTML = `<span class="date-value" data-type="startDate">${startDate}</span>${dateSeparator}<span class="date-value" data-type="endDate">${endDate}</span>`;
            
            const daysSpentControl = document.createElement('div');
            daysSpentControl.className = 'days-spent-control';
            daysSpentControl.innerHTML = `
                <button class="days-spent-btn minus">-</button>
                <span class="days-spent-value">${daysSpent}</span>
                <button class="days-spent-btn plus">+</button>
                <span>days</span>
            `;
            
            datesDiv.append(dateRangeSpan, daysSpentControl);
            if (startDate || endDate || parseInt(daysSpent, 10) > 0) {
                nodeWrapper.classList.add('has-dates');
            }
            // Apply global dates visibility state
            if (!areDatesVisible) {
                datesDiv.style.display = 'none';
            }
            nodeWrapper.appendChild(datesDiv);
            
            // Comment Div
            let commentText = '';
            if (nodeData.comment) {
                if (typeof nodeData.comment === 'string') {
                    commentText = nodeData.comment;
                } else if (typeof nodeData.comment === 'object') {
                    if (nodeData.comment._) {
                        commentText = nodeData.comment._;
                    } else if (Array.isArray(nodeData.comment) && nodeData.comment[0]) {
                        commentText = typeof nodeData.comment[0] === 'string' 
                            ? nodeData.comment[0] 
                            : (nodeData.comment[0]._ || '');
                    }
                }
            }
            
            const commentDiv = document.createElement('div');
            commentDiv.className = 'node-comment';
            commentDiv.textContent = commentText;
            if(commentText && commentText.trim()) {
                nodeWrapper.classList.add('has-comment');
            }
            nodeWrapper.appendChild(commentDiv);
            
            nodeDiv.appendChild(nodeWrapper);
            
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'node-parent';
            nodeDiv.appendChild(childrenContainer);
            
            parentElement.appendChild(nodeDiv);
            
            // Set the --original-bg for the flash animation *after* it's in the DOM
            const originalBg = getComputedStyle(nodeContentDiv).getPropertyValue('background-color');
            nodeContentDiv.style.setProperty('--original-bg', originalBg);
            
            // Add event listeners exactly like the original
            toggleSpan.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!childrenContainer.classList.contains('collapsed')) {
                    const descendantParents = childrenContainer.querySelectorAll('.node-parent');
                    descendantParents.forEach(parent => parent.classList.add('collapsed'));
                    
                    const descendantToggles = childrenContainer.querySelectorAll('.node-toggle');
                    descendantToggles.forEach(toggle => toggle.textContent = '‚ûï');
                }
                childrenContainer.classList.toggle('collapsed');
                toggleSpan.textContent = childrenContainer.classList.contains('collapsed') ? '‚ûï' : '‚Äì';
                updateToggleAllButton();
            });
            
            statusIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentStatus = nodeDiv.dataset.status;
                let newStatus;
                if (currentStatus === 'pending') newStatus = 'in-progress';
                else if (currentStatus === 'in-progress') newStatus = 'completed';
                else newStatus = 'pending';
                setNodeStatusRecursive(nodeDiv, newStatus);
                autoSave();
            });
            
            titleSpan.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                titleSpan.contentEditable = true;
                titleSpan.focus();
            });
            titleSpan.addEventListener('blur', () => {
                titleSpan.contentEditable = false;
                autoSave();
            });
            titleSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    titleSpan.blur();
                }
            });
            
            dateIcon.addEventListener('click', e => {
                e.stopPropagation();
                datesDiv.style.display = datesDiv.style.display === 'flex' ? 'none' : 'flex';
                nodeWrapper.classList.toggle('has-dates', datesDiv.style.display === 'flex');
            });
            
            dateRangeSpan.querySelectorAll('.date-value').forEach(dateEl => {
                dateEl.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    dateEl.contentEditable = true;
                    dateEl.focus();
                });
                dateEl.addEventListener('blur', () => {
                    dateEl.contentEditable = false;
                    autoSave();
                });
                dateEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        dateEl.blur();
                    }
                });
            });
            
            const daysSpentValue = daysSpentControl.querySelector('.days-spent-value');
            daysSpentControl.querySelector('.plus').addEventListener('click', e => {
                e.stopPropagation();
                let current = parseInt(daysSpentValue.textContent, 10);
                daysSpentValue.textContent = current + 1;
                autoSave();
            });
            daysSpentControl.querySelector('.minus').addEventListener('click', e => {
                e.stopPropagation();
                let current = parseInt(daysSpentValue.textContent, 10);
                if (current > 0) {
                    daysSpentValue.textContent = current - 1;
                    autoSave();
                }
            });
            
            commentIcon.addEventListener('click', e => {
                e.stopPropagation();
                commentDiv.style.display = commentDiv.style.display === 'block' ? 'none' : 'block';
            });
            
            commentDiv.addEventListener('dblclick', e => {
                e.stopPropagation();
                commentDiv.contentEditable = true;
                commentDiv.focus();
            });
            commentDiv.addEventListener('blur', () => {
                commentDiv.contentEditable = false;
                if(commentDiv.textContent.trim() === "") nodeWrapper.classList.remove('has-comment');
                else nodeWrapper.classList.add('has-comment');
                autoSave();
            });

            // Extract and create advanced elements
            const advancedElements = extractAdvancedElements(nodeData);

            // Create and append code element if exists
            let codeDiv = null;
            if (advancedElements.code) {
                codeDiv = createCodeElement(advancedElements.code, nodeWrapper);
                nodeWrapper.appendChild(codeDiv);
                
                // Add click handler to code icon
                codeIcon.addEventListener('click', e => {
                    e.stopPropagation();
                    codeDiv.style.display = codeDiv.style.display === 'block' ? 'none' : 'block';
                });
            } else {
                codeIcon.style.display = 'none';
            }

            // Create and append task prompt element if exists
            let taskDiv = null;
            if (advancedElements.taskPrompt) {
                taskDiv = createTaskPromptElement(advancedElements.taskPrompt, nodeWrapper);
                nodeWrapper.appendChild(taskDiv);
                
                // Add click handler to task icon
                taskIcon.addEventListener('click', e => {
                    e.stopPropagation();
                    taskDiv.style.display = taskDiv.style.display === 'block' ? 'none' : 'block';
                });
            } else {
                taskIcon.style.display = 'none';
            }

            // Create and append CLI command element if exists
            let cliDiv = null;
            if (advancedElements.cliCommand) {
                cliDiv = createCliCommandElement(advancedElements.cliCommand, nodeWrapper);
                nodeWrapper.appendChild(cliDiv);
                
                // Add click handler to CLI icon
                cliIcon.addEventListener('click', e => {
                    e.stopPropagation();
                    cliDiv.style.display = cliDiv.style.display === 'block' ? 'none' : 'block';
                });
            } else {
                cliIcon.style.display = 'none';
            }
            
            addIcon.addEventListener('click', e => {
                e.stopPropagation();
                const newNodeData = {
                    $: {
                        title: "New Idea",
                        priority: "medium",
                        status: "pending",
                        id: generateId(),
                        startDate: "",
                        endDate: "",
                        daysSpent: "0"
                    }
                };
                renderNode(newNodeData, childrenContainer);
                if (childrenContainer.classList.contains('collapsed')) {
                    childrenContainer.classList.remove('collapsed');
                    toggleSpan.textContent = '‚Äì';
                }
                autoSave();
            });
            
            deleteIcon.addEventListener('click', e => {
                e.stopPropagation();
                if (confirm('Delete this node and all its children?')) {
                    nodeDiv.remove();
                    autoSave();
                }
            });
            
            // Context menu
            nodeDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e, nodeDiv);
            });
            
            // Render children
            if (nodeData.node) {
                const childNodes = Array.isArray(nodeData.node) ? nodeData.node : [nodeData.node];
                childNodes.forEach(childData => {
                    renderNode(childData, childrenContainer);
                });
            }
            
            return nodeDiv;
        }

        // Helper functions
        function generateId() {
            return crypto.randomUUID();
        }

        // Helper function to copy text to clipboard
        async function copyToClipboard(text, button) {
            try {
                await navigator.clipboard.writeText(text);
                button.classList.add('copied');
                button.textContent = '‚úì Copied';
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.textContent = 'Copy';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                button.textContent = 'Failed';
                setTimeout(() => {
                    button.textContent = 'Copy';
                }, 2000);
            }
        }

        // Parse and extract new XML elements
        function extractAdvancedElements(nodeData) {
            const elements = {
                code: null,
                taskPrompt: null,
                cliCommand: null
            };
            
            // Extract code element
            if (nodeData.code) {
                const codeData = Array.isArray(nodeData.code) ? nodeData.code[0] : nodeData.code;
                if (typeof codeData === 'string') {
                    elements.code = { text: codeData, language: 'javascript' };
                } else if (codeData && codeData._) {
                    elements.code = {
                        text: codeData._,
                        language: codeData.$ && codeData.$.language || 'javascript'
                    };
                }
            }
            
            // Extract task_prompt_for_llm element
            if (nodeData.task_prompt_for_llm) {
                const taskData = Array.isArray(nodeData.task_prompt_for_llm) ? 
                    nodeData.task_prompt_for_llm[0] : nodeData.task_prompt_for_llm;
                if (typeof taskData === 'string') {
                    elements.taskPrompt = taskData;
                } else if (taskData && taskData._) {
                    elements.taskPrompt = taskData._;
                }
            }
            
            // Extract cli_command element
            if (nodeData.cli_command) {
                const cliData = Array.isArray(nodeData.cli_command) ? 
                    nodeData.cli_command[0] : nodeData.cli_command;
                if (typeof cliData === 'string') {
                    elements.cliCommand = cliData;
                } else if (cliData && cliData._) {
                    elements.cliCommand = cliData._;
                }
            }
            
            return elements;
        }

        // Create code block element
        function createCodeElement(codeData, nodeWrapper) {
            const codeDiv = document.createElement('div');
            codeDiv.className = 'node-code';
            
            const header = document.createElement('div');
            header.className = 'code-header';
            
            const langLabel = document.createElement('span');
            langLabel.className = 'code-language';
            langLabel.textContent = codeData.language.toUpperCase();
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.onclick = (e) => {
                e.stopPropagation();
                copyToClipboard(codeData.text, copyBtn);
            };
            
            header.appendChild(langLabel);
            header.appendChild(copyBtn);
            
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            code.className = `language-${codeData.language}`;
            code.textContent = codeData.text;
            pre.appendChild(code);
            
            codeDiv.appendChild(header);
            codeDiv.appendChild(pre);
            
            // Apply syntax highlighting
            if (typeof Prism !== 'undefined') {
                Prism.highlightElement(code);
            }
            
            nodeWrapper.classList.add('has-code');
            return codeDiv;
        }

        // Create task prompt element
        function createTaskPromptElement(taskPromptText, nodeWrapper) {
            const taskDiv = document.createElement('div');
            taskDiv.className = 'node-task-prompt';
            
            const header = document.createElement('div');
            header.className = 'task-prompt-header';
            
            const label = document.createElement('span');
            label.className = 'task-prompt-label';
            label.innerHTML = 'ü§ñ LLM Task Prompt';
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.onclick = (e) => {
                e.stopPropagation();
                copyToClipboard(taskPromptText, copyBtn);
            };
            
            header.appendChild(label);
            header.appendChild(copyBtn);
            
            const content = document.createElement('div');
            content.className = 'task-prompt-content';
            content.textContent = taskPromptText;
            
            taskDiv.appendChild(header);
            taskDiv.appendChild(content);
            
            nodeWrapper.classList.add('has-task-prompt');
            return taskDiv;
        }

        // Create CLI command element
        function createCliCommandElement(cliCommandText, nodeWrapper) {
            const cliDiv = document.createElement('div');
            cliDiv.className = 'node-cli-command';
            
            const header = document.createElement('div');
            header.className = 'cli-command-header';
            
            const label = document.createElement('span');
            label.className = 'cli-command-label';
            label.innerHTML = '‚ö° CLI Commands';
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.onclick = (e) => {
                e.stopPropagation();
                copyToClipboard(cliCommandText, copyBtn);
            };
            
            header.appendChild(label);
            header.appendChild(copyBtn);
            
            const content = document.createElement('div');
            content.className = 'cli-command-content';
            content.textContent = cliCommandText;
            
            cliDiv.appendChild(header);
            cliDiv.appendChild(content);
            
            nodeWrapper.classList.add('has-cli-command');
            return cliDiv;
        }
        
        function setNodeStatusRecursive(node, newStatus) {
            // Remove old status class and add new one
            node.classList.remove(`status-${node.dataset.status}`);
            node.dataset.status = newStatus;
            node.classList.add(`status-${newStatus}`);
            
            // Update status icon
            const statusIcon = node.querySelector('.icon-status');
            if (newStatus === 'pending') statusIcon.innerHTML = 'üî≤';
            else if (newStatus === 'in-progress') statusIcon.innerHTML = 'üü°';
            else if (newStatus === 'completed') statusIcon.innerHTML = '‚úÖ';
            
            // Update children recursively
            const childrenContainer = node.querySelector('.node-parent');
            if (childrenContainer) {
                const childNodes = childrenContainer.querySelectorAll(':scope > .node');
                childNodes.forEach(childNode => {
                    setNodeStatusRecursive(childNode, newStatus);
                });
            }
            
            // Refresh board view if currently active with animation
            if (isBoardView) {
                refreshBoardWithAnimation();
            }
        }

        function getStatusIcon(status) {
            switch(status) {
                case 'completed': return '‚úÖ';
                case 'in-progress': return 'üü°';
                default: return 'üî≤';
            }
        }

        function cycleStatus(node) {
            const statuses = ['pending', 'in-progress', 'completed'];
            const currentStatus = node.dataset.status;
            const currentIndex = statuses.indexOf(currentStatus);
            const newStatus = statuses[(currentIndex + 1) % 3];
            
            node.dataset.status = newStatus;
            node.querySelector('.status-icon').textContent = getStatusIcon(newStatus);
            
            autoSave();
        }

        function toggleNode(node, toggle) {
            const parent = node.querySelector('.node-parent');
            if (parent) {
                parent.classList.toggle('collapsed');
                toggle.textContent = parent.classList.contains('collapsed') ? '‚ûï' : '‚Äì';
            }
        }

        function toggleComment(wrapper) {
            const comment = wrapper.querySelector('.node-comment');
            const hasComment = wrapper.classList.contains('has-comment');
            
            if (hasComment) {
                wrapper.classList.remove('has-comment');
                comment.style.display = 'none';
                comment.textContent = '';
            } else {
                wrapper.classList.add('has-comment');
                comment.style.display = areCommentsVisible ? 'block' : 'none';
                comment.focus();
            }
            autoSave();
        }

        function toggleDates(wrapper) {
            const dates = wrapper.querySelector('.node-dates');
            const hasDates = wrapper.classList.contains('has-dates');
            
            if (hasDates) {
                wrapper.classList.remove('has-dates');
                dates.style.display = 'none';
            } else {
                wrapper.classList.add('has-dates');
                dates.style.display = areDatesVisible ? 'flex' : 'none';
            }
            autoSave();
        }

        function changeDays(node, delta) {
            const daysValue = node.querySelector('.days-value');
            const current = parseInt(daysValue.textContent);
            const newValue = Math.max(0, current + delta);
            daysValue.textContent = newValue;
            autoSave();
        }

        function addChildNode(parentNode) {
            let parent = parentNode.querySelector('.node-parent');
            
            // If no parent container exists, create one
            if (!parent) {
                parent = document.createElement('div');
                parent.className = 'node-parent';
                parentNode.appendChild(parent);
                
                // Add toggle button to parent content
                const content = parentNode.querySelector('.node-content');
                if (!content.querySelector('.node-toggle')) {
                    const toggle = document.createElement('span');
                    toggle.className = 'node-toggle';
                    toggle.textContent = '‚Äì';
                    toggle.onclick = () => toggleNode(parentNode, toggle);
                    content.insertBefore(toggle, content.firstChild);
                }
            }
            
            const newNode = {
                $: {
                    title: 'New Node',
                    priority: 'medium',
                    status: 'pending',
                    id: generateId()
                }
            };
            
            // Inherit data attributes from parent for save-split functionality
            if (parentNode.dataset.dataSource) {
                newNode.$.dataSource = parentNode.dataset.dataSource;
            } else {
                // If parent has no dataSource, use current file as source
                newNode.$.dataSource = currentFile;
            }
            
            const newEl = renderNode(newNode, true);
            parent.appendChild(newEl);
            
            // Focus on the new node's title
            const title = newEl.querySelector('.node-title');
            if (title) {
                title.focus();
                title.select();
            }
            
            autoSave();
        }

        function deleteNode(node) {
            if (confirm('Delete this node and all its children?')) {
                node.remove();
                autoSave();
            }
        }

        function showContextMenu(e, node) {
            const menu = document.getElementById('contextMenu');
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            menu.classList.add('visible');
            
            menu.querySelectorAll('.context-menu-item').forEach(item => {
                item.onclick = () => {
                    node.dataset.priority = item.dataset.priority;
                    menu.classList.remove('visible');
                    renderMindMap(); // Re-render to apply new priority
                    autoSave();
                };
            });
        }

        // Build XML from DOM
        function generateXMLString() {
            const nodes = document.querySelectorAll('#mindMapContainer > .node');
            console.log('Generating XML for', nodes.length, 'nodes');
            const xmlNodes = Array.from(nodes).map((node, i) => {
                console.log(`Node ${i}: id="${node.dataset.id}", title="${node.querySelector('.node-title')?.textContent}"`);
                return buildNodeXML(node);
            });
            
            const xml = `<?xml version="1.0" encoding="UTF-8"?>
<project_plan>
${xmlNodes.join('\n')}
</project_plan>`;
            
            console.log('Generated XML contains "undefined":', xml.includes('id="undefined"'));
            console.log('First 300 chars of generated XML:', xml.substring(0, 300));
            return xml;
        }

        function buildNodeXML(node, indent = '    ') {
            const wrapper = node.querySelector('.node-wrapper');
            const title = wrapper.querySelector('.node-title').textContent;
            const comment = wrapper.querySelector('.node-comment')?.textContent || '';
            const startDate = wrapper.querySelector('.date-value[data-type="startDate"]')?.textContent || '';
            const endDate = wrapper.querySelector('.date-value[data-type="endDate"]')?.textContent || '';
            const daysSpent = wrapper.querySelector('.days-spent-value')?.textContent || '0';
            
            // Extract advanced elements
            const codeDiv = wrapper.querySelector('.node-code');
            const taskDiv = wrapper.querySelector('.node-task-prompt');
            const cliDiv = wrapper.querySelector('.node-cli-command');
            
            const codeData = codeDiv && codeDiv.style.display !== 'none' ? {
                language: codeDiv.querySelector('.code-language')?.textContent.toLowerCase() || 'javascript',
                text: codeDiv.querySelector('code')?.textContent || ''
            } : null;
            
            const taskText = taskDiv && taskDiv.style.display !== 'none' ? 
                taskDiv.querySelector('.task-prompt-content')?.textContent || '' : '';
                
            const cliText = cliDiv && cliDiv.style.display !== 'none' ? 
                cliDiv.querySelector('.cli-command-content')?.textContent || '' : '';
            
            // Fix undefined IDs on the fly
            let nodeId = node.dataset.id;
            if (!nodeId || nodeId === 'undefined') {
                nodeId = generateId();
                node.dataset.id = nodeId;
                console.warn('Fixed undefined ID, generated new ID:', nodeId);
            }
            
            const attrs = [
                `title="${escapeXML(title)}"`,
                `priority="${node.dataset.priority}"`,
                `status="${node.dataset.status}"`,
                `id="${nodeId}"`
            ];
            
            if (startDate) attrs.push(`startDate="${startDate}"`);
            if (endDate) attrs.push(`endDate="${endDate}"`);
            if (daysSpent !== '0') attrs.push(`daysSpent="${daysSpent}"`);
            
            // Note: Removed data attributes as they cause XML parsing errors
            // The server's cleanup function will handle source attribution properly
            
            const childContainer = node.querySelector('.node-parent');
            const childNodes = childContainer ? childContainer.querySelectorAll(':scope > .node') : [];
            
            const hasContent = childNodes.length > 0 || comment || codeData?.text || taskText || cliText;
            
            if (!hasContent) {
                return `${indent}<node ${attrs.join(' ')}/>`;
            }
            
            let xml = `${indent}<node ${attrs.join(' ')}>`;
            
            if (comment) {
                xml += `\n${indent}    <comment>${escapeXML(comment)}</comment>`;
            }
            
            if (codeData?.text) {
                xml += `\n${indent}    <code language="${codeData.language}">${escapeXML(codeData.text)}</code>`;
            }
            
            if (taskText) {
                xml += `\n${indent}    <task_prompt_for_llm>${escapeXML(taskText)}</task_prompt_for_llm>`;
            }
            
            if (cliText) {
                xml += `\n${indent}    <cli_command>${escapeXML(cliText)}</cli_command>`;
            }
            
            if (childNodes.length > 0) {
                xml += '\n' + Array.from(childNodes).map(child => 
                    buildNodeXML(child, indent + '    ')
                ).join('\n');
            }
            
            xml += `\n${indent}</node>`;
            
            return xml;
        }

        function escapeXML(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // Auto-save functionality
        function autoSave() {
            console.log('AutoSave triggered for file:', currentFile);
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                if (currentFile) {
                    console.log('Executing saveFile() for:', currentFile);
                    saveFile();
                } else {
                    console.log('No currentFile set, skipping save');
                }
            }, 1000);
        }

        async function saveFile() {
            try {
                const xml = generateXMLString();
                const response = await fetch(`${API_BASE}/save-split`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: currentFile,
                        data: xml,
                        folder: currentFolder
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Save failed');
                }
                
                // Show save indicator
                const indicator = document.getElementById('saveIndicator');
                indicator.style.opacity = '1';
                setTimeout(() => indicator.style.opacity = '0', 1500);
                
                // Update check time after successful save
                lastCheckTime = Date.now();
            } catch (error) {
                console.error('Failed to save:', error);
            }
        }

        // Check for file changes and reload if necessary
        async function checkForChanges() {
            if (!currentFile) return;
            
            try {
                const response = await fetch(`${API_BASE}/check-changes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: currentFile,
                        folder: currentFolder,
                        lastCheck: lastCheckTime
                    })
                });

                const result = await response.json();
                if (result.needsReload) {
                    console.log('Files have changed, reloading...');
                    await loadFile(currentFile);
                    lastCheckTime = Date.now();
                    
                    // Show notification
                    const indicator = document.getElementById('saveIndicator');
                    indicator.textContent = 'Synced!';
                    indicator.style.opacity = '1';
                    indicator.style.backgroundColor = '#10b981';
                    setTimeout(() => {
                        indicator.style.opacity = '0';
                        indicator.textContent = 'Saved';
                        indicator.style.backgroundColor = '#3b82f6';
                    }, 2000);
                }
            } catch (error) {
                console.error('Error checking for changes:', error);
            }
        }

        // Start sync checking when file is loaded
        function startSyncCheck() {
            if (syncCheckInterval) {
                clearInterval(syncCheckInterval);
            }
            syncCheckInterval = setInterval(checkForChanges, 3000); // Check every 3 seconds
        }

        // Stop sync checking
        function stopSyncCheck() {
            if (syncCheckInterval) {
                clearInterval(syncCheckInterval);
                syncCheckInterval = null;
            }
        }

        // Global toggles
        function toggleAllComments() {
            areCommentsVisible = !areCommentsVisible;
            document.querySelectorAll('.node-comment').forEach(comment => {
                const wrapper = comment.closest('.node-wrapper');
                if (wrapper && wrapper.classList.contains('has-comment')) {
                    comment.style.display = areCommentsVisible ? 'block' : 'none';
                }
            });
            updateToggleCommentsButton();
        }

        function toggleAllDates() {
            areDatesVisible = !areDatesVisible;
            document.querySelectorAll('.node-dates').forEach(dates => {
                dates.style.display = areDatesVisible ? 'flex' : 'none';
            });
            updateToggleDatesButton();
        }

        function toggleAllAddButtons() {
            areAddButtonsVisible = !areAddButtonsVisible;
            if (areAddButtonsVisible) {
                document.body.classList.remove('add-hidden');
            } else {
                document.body.classList.add('add-hidden');
            }
            updateToggleAddButton();
        }

        function toggleAllNodes() {
            const rootNode = document.querySelector('#mindMapContainer > .node');
            if (!rootNode) return;
            
            const rootParent = rootNode.querySelector('.node-parent');
            if (!rootParent) return;
            
            const isCollapsed = rootParent.classList.contains('collapsed');
            
            document.querySelectorAll('.node-parent').forEach(parent => {
                if (isCollapsed) {
                    parent.classList.remove('collapsed');
                } else {
                    parent.classList.add('collapsed');
                }
            });
            
            document.querySelectorAll('.node-toggle').forEach(toggle => {
                toggle.textContent = isCollapsed ? '‚Äì' : '‚ûï';
            });
            
            updateToggleAllButton();
        }

        function toggleFlash() {
            areFlashesVisible = !areFlashesVisible;
            if (areFlashesVisible) {
                document.body.classList.add('flash-active');
            } else {
                document.body.classList.remove('flash-active');
            }
            updateToggleFlashButton();
        }

        function toggleAnimateLines() {
            areLinesAnimated = !areLinesAnimated;
            if (areLinesAnimated) {
                document.body.classList.add('lines-animated');
            } else {
                document.body.classList.remove('lines-animated');
            }
            updateToggleAnimateLinesButton();
        }

        // Board view state
        let isBoardView = false;

        // Board view toggle functionality
        function toggleBoardView() {
            isBoardView = !isBoardView;
            const mindMapContainer = document.getElementById('mindMapContainer');
            const boardContainer = document.getElementById('boardContainer');
            const toggleBtn = document.getElementById('toggleViewBtn');
            
            if (isBoardView) {
                // Show board, hide mind map
                mindMapContainer.style.display = 'none';
                boardContainer.style.display = 'block';
                toggleBtn.innerHTML = 'üß† <span class="btn-text">Mind Map</span>';
                toggleBtn.classList.remove('btn-info');
                toggleBtn.classList.add('btn-success');
                
                // Populate the board with current data
                populateBoard();
            } else {
                // Show mind map, hide board
                mindMapContainer.style.display = 'flex';
                boardContainer.style.display = 'none';
                toggleBtn.innerHTML = 'üìã <span class="btn-text">Board View</span>';
                toggleBtn.classList.remove('btn-success');
                toggleBtn.classList.add('btn-info');
            }
        }

        // Populate board with nodes based on their status
        function refreshBoard() {
            if (!isBoardView) return;
            
            // For now, do a full refresh - could be optimized later
            populateBoard();
        }
        
        // Enhanced refresh that moves individual cards between columns
        function refreshBoardWithAnimation() {
            if (!isBoardView) return;
            
            if (!xmlData) {
                console.log('No XML data for board refresh');
                return;
            }
            
            // Get all current nodes
            const allNodes = [];
            // Handle different XML root structures (project_plan, mindmap, etc.)
            const rootData = xmlData.project_plan || xmlData.mindmap || xmlData.root || xmlData;
            collectNodesRecursively(rootData, allNodes);
            
            // Get column containers
            const todoCards = document.getElementById('todoCards');
            const inProgressCards = document.getElementById('inProgressCards');
            const doneCards = document.getElementById('doneCards');
            
            if (!todoCards || !inProgressCards || !doneCards) {
                console.error('Board container elements not found for animation refresh');
                return;
            }
            
            // Check each existing card to see if it needs to be moved
            const allCards = [...todoCards.children, ...inProgressCards.children, ...doneCards.children];
            
            // If no existing cards, do a full populate instead
            if (allCards.length === 0) {
                console.log('No existing cards, doing full populate');
                populateBoard();
                return;
            }
            
            allCards.forEach(card => {
                const nodeId = card.dataset.nodeId;
                const node = allNodes.find(n => n.id === nodeId);
                
                if (!node) {
                    // Node was deleted, remove card with animation
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.8)';
                    setTimeout(() => card.remove(), 300);
                    return;
                }
                
                const nodeStatus = node.status || 'pending';
                const currentColumn = card.parentElement;
                let targetColumn;
                
                // Determine target column based on status
                if (nodeStatus === 'pending') targetColumn = todoCards;
                else if (nodeStatus === 'in-progress') targetColumn = inProgressCards;
                else if (nodeStatus === 'completed') targetColumn = doneCards;
                
                // Move card if it's in the wrong column
                if (currentColumn !== targetColumn) {
                    card.style.transform = 'translateX(20px)';
                    card.style.opacity = '0.7';
                    
                    setTimeout(() => {
                        targetColumn.appendChild(card);
                        card.style.transform = 'translateX(0)';
                        card.style.opacity = '1';
                    }, 200);
                }
            });
            
            // Add any new cards that don't exist yet
            allNodes.forEach(node => {
                const existingCard = document.querySelector(`[data-node-id="${node.id}"]`);
                if (!existingCard) {
                    const nodeStatus = node.status || 'pending';
                    let targetColumn;
                    let columnType;
                    
                    if (nodeStatus === 'pending') {
                        targetColumn = todoCards;
                        columnType = 'todo';
                    } else if (nodeStatus === 'in-progress') {
                        targetColumn = inProgressCards;
                        columnType = 'in-progress';
                    } else if (nodeStatus === 'completed') {
                        targetColumn = doneCards;
                        columnType = 'done';
                    }
                    
                    const newCard = createTaskCard(node, columnType);
                    newCard.style.opacity = '0';
                    newCard.style.transform = 'scale(0.8)';
                    targetColumn.appendChild(newCard);
                    
                    // Animate in
                    setTimeout(() => {
                        newCard.style.opacity = '1';
                        newCard.style.transform = 'scale(1)';
                    }, 100);
                }
            });
        }
        
        function populateBoard() {
            console.log('Populating board...');
            const todoCards = document.getElementById('todoCards');
            const inProgressCards = document.getElementById('inProgressCards');
            const doneCards = document.getElementById('doneCards');
            const boardTitle = document.getElementById('boardTitle');
            
            if (!todoCards || !inProgressCards || !doneCards) {
                console.error('Board container elements not found');
                return;
            }
            
            // Clear existing cards
            todoCards.innerHTML = '';
            inProgressCards.innerHTML = '';
            doneCards.innerHTML = '';
            
            // Set board title from current file
            if (boardTitle) {
                boardTitle.textContent = currentFile || 'Project';
            }
            
            console.log('xmlData:', xmlData);
            console.log('currentFile:', currentFile);
            
            if (!xmlData) {
                console.log('No XML data available');
                // Show empty state
                showEmptyBoard();
                return;
            }
            
            // Collect all nodes recursively
            const allNodes = [];
            // Handle different XML root structures (project_plan, mindmap, etc.)
            const rootData = xmlData.project_plan || xmlData.mindmap || xmlData.root || xmlData;
            collectNodesRecursively(rootData, allNodes);
            console.log('Collected nodes:', allNodes.length);
            
            // Group nodes by status
            const todoNodes = allNodes.filter(node => !node.status || node.status === 'pending');
            const inProgressNodes = allNodes.filter(node => node.status === 'in-progress');
            const doneNodes = allNodes.filter(node => node.status === 'completed');
            
            console.log('Todo nodes:', todoNodes.length, 'In Progress:', inProgressNodes.length, 'Done:', doneNodes.length);
            
            // Populate columns
            populateColumn(todoCards, todoNodes, 'todo');
            populateColumn(inProgressCards, inProgressNodes, 'in-progress');
            populateColumn(doneCards, doneNodes, 'done');
            
            // Update counters
            document.getElementById('todoCount').textContent = todoNodes.length;
            document.getElementById('inProgressCount').textContent = inProgressNodes.length;
            document.getElementById('doneCount').textContent = doneNodes.length;
        }
        
        // Recursively collect all nodes from XML data
        function collectNodesRecursively(nodeData, allNodes, parentPath = '') {
            if (nodeData.node) {
                const nodes = Array.isArray(nodeData.node) ? nodeData.node : [nodeData.node];
                nodes.forEach((node, index) => {
                    // Extract attributes from $ property if they exist
                    const nodeAttrs = node.$ || {};
                    const title = nodeAttrs.title || node.title || 'Untitled';
                    const nodePath = parentPath ? `${parentPath} > ${title}` : title;
                    
                    allNodes.push({
                        id: nodeAttrs.id || node.id,
                        title: title,
                        status: nodeAttrs.status || node.status || 'pending',
                        priority: nodeAttrs.priority || node.priority,
                        assignee: nodeAttrs.assignee || node.assignee,
                        startDate: nodeAttrs.startDate || node.startDate,
                        endDate: nodeAttrs.endDate || node.endDate,
                        comment: node.comment,
                        path: nodePath,
                        parentPath: parentPath,
                        originalNode: node // Keep original node data
                    });
                    
                    // Recursively collect child nodes
                    collectNodesRecursively(node, allNodes, nodePath);
                });
            }
        }
        
        // Populate a specific column with nodes
        function populateColumn(container, nodes, columnType) {
            if (nodes.length === 0) {
                container.innerHTML = '<div class="empty-column">No tasks</div>';
                return;
            }
            
            nodes.forEach(node => {
                const card = createTaskCard(node, columnType);
                container.appendChild(card);
            });
        }
        
        // Create a task card element (simplified - title only)
        function createTaskCard(node, columnType) {
            const card = document.createElement('div');
            card.className = `task-card${node.priority ? ` priority-${node.priority}` : ''}`;
            card.dataset.nodeId = node.id;
            
            // Task title only
            const title = document.createElement('div');
            title.className = 'task-title';
            title.textContent = node.title || 'Untitled Task';
            
            // Add click handler to focus on node in mind map
            card.addEventListener('click', () => {
                // Switch back to mind map view and highlight the node
                if (isBoardView) {
                    toggleBoardView();
                }
                // Find and highlight the node
                setTimeout(() => {
                    const nodeElement = document.querySelector(`[data-id="${node.id}"]`);
                    if (nodeElement) {
                        nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        nodeElement.style.animation = 'pulse 2s ease-in-out';
                        setTimeout(() => {
                            nodeElement.style.animation = '';
                        }, 2000);
                    }
                }, 300);
            });
            
            card.appendChild(title);
            
            return card;
        }
        
        // Show empty board state
        function showEmptyBoard() {
            const columns = ['todoCards', 'inProgressCards', 'doneCards'];
            columns.forEach(columnId => {
                document.getElementById(columnId).innerHTML = '<div class="empty-column">No data loaded</div>';
            });
            
            // Reset counters
            document.getElementById('todoCount').textContent = '0';
            document.getElementById('inProgressCount').textContent = '0';
            document.getElementById('doneCount').textContent = '0';
        }

        // Button text updates
        function updateToggleCommentsButton() {
            const btnText = document.querySelector('#toggleCommentsBtn .btn-text');
            btnText.textContent = areCommentsVisible ? 'Hide Comments' : 'Show Comments';
        }

        function updateToggleDatesButton() {
            const btnText = document.querySelector('#toggleDatesBtn .btn-text');
            btnText.textContent = areDatesVisible ? 'Hide Dates' : 'Show Dates';
        }

        function updateToggleAddButton() {
            const btnText = document.querySelector('#toggleAddBtn .btn-text');
            btnText.textContent = areAddButtonsVisible ? 'Hide Add Buttons' : 'Show Add Buttons';
        }

        function updateToggleAllButton() {
            const rootNode = document.querySelector('#mindMapContainer > .node');
            if (!rootNode) return;
            
            const rootParent = rootNode.querySelector('.node-parent');
            if (!rootParent) return;
            
            const btnText = document.querySelector('#toggleAllBtn .btn-text');
            btnText.textContent = rootParent.classList.contains('collapsed') ? 'Expand All' : 'Collapse All';
        }

        function updateToggleFlashButton() {
            const btnText = document.querySelector('#toggleFlashBtn .btn-text');
            btnText.textContent = areFlashesVisible ? 'Stop Flash' : 'Start Flash';
        }

        function updateToggleAnimateLinesButton() {
            const btnText = document.querySelector('#toggleAnimateLinesBtn .btn-text');
            btnText.textContent = areLinesAnimated ? 'Stop Lines' : 'Animate Lines';
        }

        // Sidebar toggle functionality
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const toggle = document.getElementById('sidebarToggle');
            
            sidebar.classList.toggle('collapsed');
            
            if (sidebar.classList.contains('collapsed')) {
                toggle.textContent = '‚Ä∫';
                toggle.title = 'Expand Sidebar';
            } else {
                toggle.textContent = '‚Äπ';
                toggle.title = 'Collapse Sidebar';
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Sidebar toggle button
            document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
            
            // Change Root button
            document.getElementById('changeRootBtn').addEventListener('click', showFilesystemBrowser);
            
            // Folder list
            document.getElementById('folderList').addEventListener('click', (e) => {
                const folderItem = e.target.closest('.folder-item');
                if (folderItem) {
                    changeFolder(folderItem.dataset.folder);
                }
            });
            
            // File list
            document.getElementById('fileList').addEventListener('click', (e) => {
                const fileItem = e.target.closest('.file-item');
                if (fileItem) {
                    loadFile(fileItem.dataset.file);
                }
            });
            
            // New file button
            document.getElementById('newFileBtn').onclick = async () => {
                const filename = prompt('Enter filename (e.g., project.xml):');
                if (filename && filename.endsWith('.xml')) {
                    try {
                        const response = await fetch(`${API_BASE}/create`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ filename })
                        });
                        
                        if (response.ok) {
                            await loadFileList();
                            loadFile(filename);
                        } else {
                            const error = await response.json();
                            alert(error.error);
                        }
                    } catch (error) {
                        alert('Failed to create file');
                    }
                }
            };
            
            // Control buttons
            document.getElementById('saveBtn').onclick = () => {
                if (currentFile) {
                    saveFile();
                }
            };
            
            document.getElementById('toggleCommentsBtn').onclick = toggleAllComments;
            document.getElementById('toggleDatesBtn').onclick = toggleAllDates;
            document.getElementById('toggleAddBtn').onclick = toggleAllAddButtons;
            document.getElementById('toggleAllBtn').onclick = toggleAllNodes;
            document.getElementById('toggleFlashBtn').onclick = toggleFlash;
            document.getElementById('toggleAnimateLinesBtn').onclick = toggleAnimateLines;
            document.getElementById('cleanupBtn').onclick = cleanupIds;
            document.getElementById('toggleViewBtn').onclick = toggleBoardView;
            
            // Hide context menu on click
            document.addEventListener('click', () => {
                document.getElementById('contextMenu').classList.remove('visible');
            });
        }

        // Clean up IDs across all XML files
        async function cleanupIds() {
            const button = document.getElementById('cleanupBtn');
            const originalText = button.innerHTML;
            
            try {
                button.innerHTML = 'üîß <span class="btn-text">Cleaning...</span>';
                button.disabled = true;
                
                const response = await fetch(`${API_BASE}/cleanup-ids`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    button.innerHTML = '‚úÖ <span class="btn-text">Cleaned!</span>';
                    button.style.background = '#10b981';
                    
                    // Show success message
                    const indicator = document.getElementById('saveIndicator');
                    indicator.textContent = `Cleaned ${result.files.length} files (${result.totalIds} unique IDs)`;
                    indicator.style.opacity = '1';
                    indicator.style.backgroundColor = '#10b981';
                    
                    setTimeout(async () => {
                        indicator.style.opacity = '0';
                        indicator.textContent = 'Saved';
                        indicator.style.backgroundColor = '#3b82f6';
                        
                        // Reset button
                        button.innerHTML = originalText;
                        button.style.background = '#f59e0b';
                        button.disabled = false;
                        
                        // Reload current file to reflect changes
                        if (currentFile) {
                            await loadFile(currentFile);
                        }
                    }, 3000);
                    
                } else {
                    throw new Error(result.error || 'Cleanup failed');
                }
                
            } catch (error) {
                console.error('Cleanup error:', error);
                button.innerHTML = '‚ùå <span class="btn-text">Error</span>';
                button.style.background = '#ef4444';
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = '#f59e0b';
                    button.disabled = false;
                }, 2000);
            }
        }

        // Stop sync checking when page unloads
        window.addEventListener('beforeunload', stopSyncCheck);
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>