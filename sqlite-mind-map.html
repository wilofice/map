<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Horizontal Mind Map - SQLite Enhanced</title>
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <!-- CSS Module Imports -->
    <link rel="stylesheet" href="css/main-styles.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/progress-styles.css">
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>üìÅ Database Projects</h2>
            <button class="sidebar-toggle" id="sidebarToggle" title="Toggle Sidebar">‚Äπ</button>
        </div>
        
        <div class="sidebar-content">
            <!-- Project Selection -->
            <div class="working-root-section" id="projectSection">
                <div class="working-root-display">
                    <span class="folder-icon">üíæ</span>
                    <span class="working-root-path" id="currentProjectName">No project loaded</span>
                </div>
                <button class="folder-btn" id="switchProjectBtn" title="Switch to another project">üîÑ Switch Project</button>
            </div>
            
            <!-- Quick Project Actions -->
            <div class="folder-navigation">
                <button class="folder-btn" id="newProjectBtn">‚ûï New Project</button>
                <button class="folder-btn" id="importJsonBtn">üìÅ Import JSON</button>
                <button class="folder-btn" id="searchProjectsBtn">üîç Search Projects</button>
            </div>

            <!-- Hidden file input for JSON import -->
            <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
            
            <!-- Database Stats -->
            <div class="folder-section">
                <h3>üìä Database Stats</h3>
                <div class="db-stats" id="dbStats">
                    <div class="stat-item">
                        <span class="stat-label">Projects:</span>
                        <span class="stat-value" id="projectCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Nodes:</span>
                        <span class="stat-value" id="nodeCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Size:</span>
                        <span class="stat-value" id="dbSize">0 KB</span>
                    </div>
                </div>
            </div>
            
            <!-- Project List -->
            <div class="folder-section" id="projectListSection" style="display: none;">
                <h3>üìã Recent Projects</h3>
                <ul class="file-list" id="projectList">
                    <li class="loading">Loading projects...</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <h1>üß† Modular Horizontal Mind Map - SQLite Enhanced</h1>
            
            <div class="controls" id="controls" style="display: none;">
                <button class="btn btn-success" id="saveBtn">üíæ <span class="btn-text">Save All Changes</span></button>
                <button class="btn btn-secondary" id="toggleCommentsBtn">üí¨ <span class="btn-text">Show Comments</span></button>
                <button class="btn btn-secondary" id="toggleDatesBtn">üìÖ <span class="btn-text">Show Dates</span></button>
                <button class="btn btn-secondary" id="toggleAddBtn">‚ûï <span class="btn-text">Hide Add Buttons</span></button>
                <button class="btn btn-secondary" id="toggleAllBtn">üìÇ <span class="btn-text">Toggle All</span></button>
                <button class="btn" id="toggleFlashBtn">‚ú® <span class="btn-text">Start Flash</span></button>
                <button class="btn" id="toggleAnimateLinesBtn">„Ä∞Ô∏è <span class="btn-text">Animate Lines</span></button>
                <button class="btn btn-info" id="toggleViewBtn">üìã <span class="btn-text">Board View</span></button>
                <button class="btn" id="cleanupBtn" style="background: #f59e0b; color: white;">üîß <span class="btn-text">Clean up IDs</span></button>
                <button class="btn" id="exportBtn" style="background: #17a2b8; color: white;">üì§ <span class="btn-text">Export JSON</span></button>
            </div>

            <!-- Progress Bar -->
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div class="progress-header">
                    <div class="progress-title">
                        ÔøΩ Overall Progress
                    </div>
                    <div class="progress-percentage" id="progressPercentage">0%</div>
                </div>
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>
                <div class="progress-stats">
                    <div class="progress-stat">
                        <span class="progress-stat-icon">‚úÖ</span>
                        <span>Completed: <span class="progress-stat-value" id="completedCount">0</span></span>
                    </div>
                    <div class="progress-stat">
                        <span class="progress-stat-icon">üü°</span>
                        <span>In Progress: <span class="progress-stat-value" id="inProgressCount">0</span></span>
                    </div>
                    <div class="progress-stat">
                        <span class="progress-stat-icon">üî≤</span>
                        <span>Pending: <span class="progress-stat-value" id="pendingCount">0</span></span>
                    </div>
                    <div class="progress-stat">
                        <span class="progress-stat-icon">üìù</span>
                        <span>Total: <span class="progress-stat-value" id="totalCount">0</span></span>
                    </div>
                </div>
            </div>

            <div class="mind-map-container" id="mindMapContainer">
                <div class="empty-state">
                    <h3>Welcome to SQLite Enhanced Mind Map</h3>
                    <p>Select a project from the sidebar to begin, or create a new project.</p>
                    <div style="margin-top: 20px;">
                        <button class="btn btn-primary" onclick="showProjectSelector()">ÔøΩ Choose Project</button>
                        <button class="btn btn-success" onclick="createNewProject()">‚ûï New Project</button>
                    </div>
                </div>
            </div>

            <!-- Kanban Board View -->
            <div class="board-container" id="boardContainer" style="display: none;">
                <div class="board-header">
                    <h3>ÔøΩ Project Board - <span id="boardTitle">Project</span></h3>
                </div>
                <div class="board-columns">
                    <div class="board-column" id="todoColumn">
                        <div class="column-header">
                            <h4>ÔøΩ To Do</h4>
                            <span class="task-count" id="todoCount">0</span>
                        </div>
                        <div class="column-content" id="todoCards">
                            <!-- Cards will be dynamically populated -->
                        </div>
                    </div>
                    
                    <div class="board-column" id="inProgressColumn">
                        <div class="column-header">
                            <h4>‚ö° In Progress</h4>
                            <span class="task-count" id="inProgressBoardCount">0</span>
                        </div>
                        <div class="column-content" id="inProgressCards">
                            <!-- Cards will be dynamically populated -->
                        </div>
                    </div>
                    
                    <div class="board-column" id="doneColumn">
                        <div class="column-header">
                            <h4>‚úÖ Done</h4>
                            <span class="task-count" id="doneCount">0</span>
                        </div>
                        <div class="column-content" id="doneCards">
                            <!-- Cards will be dynamically populated -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="save-indicator" id="saveIndicator">‚úì Saved</div>

    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-priority="high">üî¥ High Priority</div>
        <div class="context-menu-item" data-priority="medium">üü° Medium Priority</div>
        <div class="context-menu-item" data-priority="low">üü¢ Low Priority</div>
        <div class="context-menu-item" onclick="deleteNode(currentContextNode)">üóëÔ∏è Delete Node</div>
    </div>

    <script>
        // Dynamic API base URL detection with fallback mechanism
        let API_BASE = null;
        let currentApiBaseIndex = 0;

        // Function to determine API base URL candidates
        const getApiBaseCandidates = () => {
            const protocol = window.location.protocol;
            const hostname = window.location.hostname;
            const currentPort = window.location.port;

            const candidates = [
                `${protocol}//${hostname}:3000/api`, // Default development port
                `${protocol}//${hostname}:8000/api`, // Alternative port
                `${protocol}//${hostname}:8080/api`, // Alternative port
            ];

            // If we have a current port, also try port+1 and the same port
            if (currentPort) {
                candidates.unshift(`${protocol}//${hostname}:${parseInt(currentPort) + 1}/api`);
                candidates.unshift(`${protocol}//${hostname}:${currentPort}/api`);
            }

            return [...new Set(candidates)]; // Remove duplicates
        };

        const API_CANDIDATES = getApiBaseCandidates();

        // Function to test API connectivity
        async function testApiConnection(apiBase) {
            try {
                const response = await fetch(`${apiBase}/files`, {
                    method: 'GET',
                    timeout: 2000 // 2 second timeout
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        // Function to find working API base
        async function findWorkingApiBase() {
            for (let i = 0; i < API_CANDIDATES.length; i++) {
                const candidate = API_CANDIDATES[i];
                console.log(`Testing API connection to: ${candidate}`);

                if (await testApiConnection(candidate)) {
                    console.log(`‚úÖ API server found at: ${candidate}`);
                    API_BASE = candidate;
                    currentApiBaseIndex = i;
                    return candidate;
                }
            }

            // If no API found, use the first candidate as fallback
            console.warn('‚ö†Ô∏è No working API server found, using default:', API_CANDIDATES[0]);
            API_BASE = API_CANDIDATES[0];
            currentApiBaseIndex = 0;
            return API_BASE;
        }

        // Function to retry with next API candidate on error
        async function retryWithNextApi() {
            if (currentApiBaseIndex < API_CANDIDATES.length - 1) {
                currentApiBaseIndex++;
                API_BASE = API_CANDIDATES[currentApiBaseIndex];
                console.log(`üîÑ Retrying with API: ${API_BASE}`);
                return true;
            }
            return false;
        }

        // Enhanced fetch with automatic API fallback
        async function fetchWithFallback(endpoint, options = {}) {
            let lastError = null;

            for (let attempt = 0; attempt < API_CANDIDATES.length; attempt++) {
                try {
                    const response = await fetch(`${API_BASE}${endpoint}`, options);
                    return response;
                } catch (error) {
                    console.warn(`API attempt ${attempt + 1} failed for ${API_BASE}${endpoint}:`, error.message);
                    lastError = error;

                    if (attempt < API_CANDIDATES.length - 1) {
                        await retryWithNextApi();
                    }
                }
            }

            throw lastError || new Error('All API candidates failed');
        }

        // Global variables
        let mindMapData = null;
        let currentFile = '';
        let currentFolder = '.';
        let isAuthenticated = false;
        let isDirty = false;
        let saveTimeout = null;

        let globalCommentsVisible = false;
        let globalDatesVisible = false;
        let globalAddButtonsVisible = true;
        let isFlashActive = false;
        let isLinesAnimated = false;
        let currentView = 'tree';

        // Auto-save function
        function autoSave() {
            if (isDirty && currentFile) {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveMindMap();
                }, 500); // Auto-save after 500ms of inactivity
            }
        }

        // Mark data as dirty and trigger auto-save
        function markDirty() {
            isDirty = true;
            autoSave();
        }

        // Initialize the application
        async function init() {
            try {
                // Find working API base
                await findWorkingApiBase();

                // Load folder list
                await loadFolderList();

                // Load file list for current folder
                await loadFileList(currentFolder);

                // Update database stats in the sidebar
                await updateDatabaseStats();

                // Try to load last opened file from localStorage
                const lastFile = localStorage.getItem('lastOpenedFile');
                if (lastFile && lastFile !== 'undefined') {
                    try {
                        await loadFile(lastFile);
                    } catch (error) {
                        console.warn('Failed to load last opened file:', error);
                    }
                }

            } catch (error) {
                console.error('Initialization failed:', error);
                showErrorMessage('Failed to initialize application. Please check your server connection.');
            }
        }

        // Show error message
        function showErrorMessage(message) {
            const container = document.getElementById('mindMapContainer');
            if (container) {
                container.innerHTML = `
                    <div class="error-state" style="text-align: center; padding: 40px; color: #e53e3e;">
                        <h3>‚ö†Ô∏è Error</h3>
                        <p>${message}</p>
                        <button class="btn btn-primary" onclick="location.reload()">üîÑ Retry</button>
                    </div>
                `;
            }
        }

        // File management functions
        async function loadFolderList() {
            try {
                const response = await fetchWithFallback('/folders');
                const data = await response.json();

                const folderList = document.getElementById('folderList');
                if (folderList && data.folders) {
                    folderList.innerHTML = data.folders.map(folder =>
                        `<li class="folder-item" data-folder="${folder}" onclick="changeFolder('${folder}')">
                            <span class="folder-icon">üìÇ</span>
                            <span>${folder}</span>
                        </li>`
                    ).join('');
                }
            } catch (error) {
                console.error('Failed to load folder list:', error);
            }
        }

        async function loadFileList(folder = '.') {
            try {
                const response = await fetchWithFallback(`/files/${folder}`);
                const data = await response.json();

                updateFileList(data.files, folder);
                updateFolderDisplay(folder);

            } catch (error) {
                console.error('Failed to load file list:', error);
                showErrorMessage('Failed to load file list. Please check your server connection.');
            }
        }

        function updateFileList(files, folder) {
            const fileList = document.getElementById('fileList');
            if (fileList && files) {
                fileList.innerHTML = files.map(file => {
                    const isXml = file.endsWith('.xml');
                    const isJson = file.endsWith('.json');
                    const fileIcon = isJson ? 'üîó' : 'üìÑ';
                    const fileClass = isJson ? 'json-file' : 'xml-file';
                    const format = isJson ? 'JSON' : 'XML';

                    return `
                        <li class="file-item ${fileClass}" data-file="${file}" onclick="loadFile('${file}', '${folder}')">
                            <span class="file-icon">${fileIcon}</span>
                            <span class="file-name" data-full-name="${file}">${file}</span>
                            <span class="file-format">${format}</span>
                        </li>
                    `;
                }).join('');
            }
        }

        function updateFolderDisplay(folder) {
            currentFolder = folder;
            const folderPath = document.querySelector('.folder-path');
            const parentFolderBtn = document.getElementById('parentFolderBtn');

            if (folderPath) {
                folderPath.textContent = folder === '.' ? 'Root' : folder;
            }

            if (parentFolderBtn) {
                parentFolderBtn.disabled = folder === '.';
            }
        }

        async function changeFolder(folder) {
            currentFolder = folder;
            await loadFileList(folder);
        }

        async function loadFile(filename, folder = null) {
            if (!filename) return;

            try {
                showLoadingIndicator(true);

                const folderParam = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                let response;

                if (filename.endsWith('.json')) {
                    // Load JSON file with conversion to XML format
                    response = await fetchWithFallback(`/load-json/${filename}${folderParam}&format=xml`);
                } else {
                    // Load XML file
                    response = await fetchWithFallback(`/load/${filename}${folderParam}`);
                }

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                mindMapData = data;
                currentFile = filename;
                currentFolder = folder || '.';
                isDirty = false;

                // Store last opened file
                localStorage.setItem('lastOpenedFile', filename);

                // Update UI
                updateTitle();
                renderMindMap(data.data);
                showControls(true);
                updateActiveFileHighlight(filename);

                console.log(`‚úÖ Loaded file: ${filename}`);

            } catch (error) {
                console.error('Failed to load file:', error);
                showErrorMessage(`Failed to load "${filename}": ${error.message}`);
            } finally {
                showLoadingIndicator(false);
            }
        }

        function updateTitle() {
            const title = document.querySelector('h1');
            if (title && currentFile) {
                const fileType = currentFile.endsWith('.json') ? 'JSON' : 'XML';
                const displayName = currentFile.replace(/\.(xml|json)$/, '');
                title.textContent = `${displayName} (${fileType})`;
            }
        }

        function updateActiveFileHighlight(filename) {
            // Remove active class from all file items
            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active class to current file
            const activeItem = document.querySelector(`[data-file="${filename}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }
        }

        function showControls(show) {
            const controls = document.getElementById('controls');
            if (controls) {
                controls.style.display = show ? 'flex' : 'none';
            }
        }

        function showLoadingIndicator(show) {
            const container = document.getElementById('mindMapContainer');
            if (show && container) {
                container.innerHTML = `
                    <div class="loading-state" style="text-align: center; padding: 40px;">
                        <div class="loading-spinner">üîÑ</div>
                        <p>Loading...</p>
                    </div>
                `;
            }
        }

        // Mind map rendering functions
        function renderMindMap(data) {
            if (!data) return;

            let nodes = [];

            // Support both XML format (xmlData.project_plan.node) and JSON format (xmlData.nodes)
            if (data && data.project_plan && data.project_plan.node) {
                nodes = Array.isArray(data.project_plan.node)
                    ? data.project_plan.node
                    : [data.project_plan.node];
            } else if (data && data.nodes) {
                nodes = Array.isArray(data.nodes) ? data.nodes : [data.nodes];
            } else {
                console.error('Invalid data structure:', data);
                showErrorMessage('Invalid file structure. Please check the file format.');
                return;
            }

            const container = document.getElementById('mindMapContainer');
            if (container && nodes.length > 0) {
                const renderedHtml = nodes.map(node => renderNode(node)).join('');
                container.innerHTML = renderedHtml;

                // Show progress container and update
                const progressContainer = document.getElementById('progressContainer');
                if (progressContainer) {
                    progressContainer.style.display = 'block';
                    updateProgress();
                }

                // Apply global visibility settings
                applyGlobalSettings();

                console.log(`Rendered ${nodes.length} root nodes`);
            } else {
                showEmptyState();
            }
        }

        function showEmptyState() {
            const container = document.getElementById('mindMapContainer');
            if (container) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>No Mind Map Data</h3>
                        <p>The selected file appears to be empty or has no valid nodes.</p>
                        <div style="margin-top: 20px;">
                            <button class="btn btn-primary" onclick="location.reload()">üîÑ Reload</button>
                        </div>
                    </div>
                `;
            }
        }

        function renderNode(nodeData, depth = 0) {
            if (!nodeData) return '';

            const nodeId = nodeData.$ ? nodeData.$.id : (nodeData.id || `node-${Date.now()}-${Math.random()}`);
            const title = nodeData.$ ? nodeData.$.title : (nodeData.title || 'Untitled');
            const status = nodeData.$ ? nodeData.$.status : (nodeData.status || 'pending');
            const priority = nodeData.$ ? nodeData.$.priority : (nodeData.priority || 'medium');

            // Extract content
            const comment = extractComment(nodeData);
            const hasComment = comment && comment.trim() !== '';

            // Extract advanced features
            const codeContent = extractCode(nodeData);
            const taskPrompt = extractTaskPrompt(nodeData);
            const cliCommand = extractCliCommand(nodeData);

            const hasCode = codeContent && codeContent.content;
            const hasTaskPrompt = taskPrompt && taskPrompt.trim() !== '';
            const hasCliCommand = cliCommand && cliCommand.trim() !== '';

            // Extract children
            const children = extractChildren(nodeData);
            const hasChildren = children && children.length > 0;

            // Check for source file information (for imported nodes)
            const sourceFile = nodeData.$ ? nodeData.$.dataSource : null;
            const isImported = nodeData.$ ? nodeData.$.dataImported === 'true' : false;
            const importFrom = nodeData.$ ? nodeData.$.dataImportFrom : null;

            let sourceIndicator = '';
            if (isImported && importFrom) {
                sourceIndicator = `<span class="source-indicator" title="Imported from ${importFrom}">üîó</span>`;
            }

            // Date handling
            const startDate = nodeData.$ ? nodeData.$.startDate : (nodeData.startDate || '');
            const endDate = nodeData.$ ? nodeData.$.endDate : (nodeData.endDate || '');
            const daysSpent = nodeData.$ ? parseInt(nodeData.$.daysSpent || '0') : (parseInt(nodeData.daysSpent || '0'));

            // Generate node HTML
            let nodeHtml = `
                <div class="node priority-${priority} status-${status}" data-priority="${priority}" data-status="${status}" data-id="${nodeId}">
                    <div class="node-wrapper ${hasComment ? 'has-comment' : ''} ${hasCode ? 'has-code' : ''} ${hasTaskPrompt ? 'has-task-prompt' : ''} ${hasCliCommand ? 'has-cli-command' : ''}" data-id="${nodeId}">
                        <div class="node-content" style="--original-bg: ${getNodeBackground(priority, status)};">
                            ${hasChildren ? '<span class="node-toggle">‚Äì</span>' : '<span class="node-toggle">‚Äì</span>'}
                            <span class="node-icon icon-status" title="Cycle Status">${getStatusIcon(status)}</span>
                            <span class="node-title">${title}</span>
                            ${sourceIndicator}
                            <span class="node-icon icon-date" title="Toggle Dates">üìÖ</span>
                            <span class="node-icon icon-comment" title="Toggle Comment">üí¨</span>
                            <span class="node-icon icon-code" title="Toggle Code" style="display: ${hasCode ? 'inline' : 'none'};">üíª</span>
                            <span class="node-icon icon-task" title="Toggle Task Prompt" style="display: ${hasTaskPrompt ? 'inline' : 'none'};">ü§ñ</span>
                            <span class="node-icon icon-cli" title="Toggle CLI Command" style="display: ${hasCliCommand ? 'inline' : 'none'};">‚ö°</span>
                            <span class="node-icon icon-add" title="Add Child Node">‚ûï</span>
                            <span class="node-icon icon-delete" title="Delete Node">üóëÔ∏è</span>
                        </div>

                        <!-- Date controls -->
                        <div class="node-dates" style="display: none;">
                            <span>
                                <span class="date-value" data-type="startDate">${startDate}</span>
                                <span class="date-value" data-type="endDate">${endDate}</span>
                            </span>
                            <div class="days-spent-control">
                                <button class="days-spent-btn minus">-</button>
                                <span class="days-spent-value">${daysSpent}</span>
                                <button class="days-spent-btn plus">+</button>
                                <span>days</span>
                            </div>
                        </div>

                        <!-- Comment section -->
                        <div class="node-comment">${comment}</div>

                        <!-- Code section -->
                        ${hasCode ? renderCodeBlock(codeContent) : ''}

                        <!-- Task prompt section -->
                        ${hasTaskPrompt ? renderTaskPromptBlock(taskPrompt) : ''}

                        <!-- CLI command section -->
                        ${hasCliCommand ? renderCliCommandBlock(cliCommand) : ''}
                    </div>

                    <!-- Children container -->
                    <div class="node-parent">
                        ${hasChildren ? children.map(child => renderNode(child, depth + 1)).join('') : ''}
                    </div>
                </div>
            `;

            return nodeHtml;
        }

        function extractComment(nodeData) {
            if (nodeData.comment) {
                return Array.isArray(nodeData.comment) ? nodeData.comment[0] : nodeData.comment;
            }
            if (nodeData.$$ && nodeData.$$.length > 0) {
                const commentNode = nodeData.$$.find(child => child['#name'] === 'comment');
                return commentNode ? (commentNode._ || '') : '';
            }
            return '';
        }

        function extractCode(nodeData) {
            if (nodeData.code) {
                return nodeData.code;
            }
            if (nodeData.$$ && nodeData.$$.length > 0) {
                const codeNode = nodeData.$$.find(child => child['#name'] === 'code');
                if (codeNode && codeNode.$ && codeNode._) {
                    return {
                        language: codeNode.$.language || 'text',
                        content: codeNode._
                    };
                }
            }
            return null;
        }

        function extractTaskPrompt(nodeData) {
            if (nodeData.taskPromptForLlm) {
                return nodeData.taskPromptForLlm;
            }
            if (nodeData.$$ && nodeData.$$.length > 0) {
                const taskNode = nodeData.$$.find(child => child['#name'] === 'taskPromptForLlm');
                return taskNode ? (taskNode._ || '') : '';
            }
            return '';
        }

        function extractCliCommand(nodeData) {
            if (nodeData.cliCommand) {
                return nodeData.cliCommand;
            }
            if (nodeData.$$ && nodeData.$$.length > 0) {
                const cliNode = nodeData.$$.find(child => child['#name'] === 'cliCommand');
                return cliNode ? (cliNode._ || '') : '';
            }
            return '';
        }

        function extractChildren(nodeData) {
            if (nodeData.children) {
                return Array.isArray(nodeData.children) ? nodeData.children : [nodeData.children];
            }
            if (nodeData.node) {
                return Array.isArray(nodeData.node) ? nodeData.node : [nodeData.node];
            }
            if (nodeData.$$ && nodeData.$$.length > 0) {
                return nodeData.$$.filter(child => child['#name'] === 'node');
            }
            return [];
        }

        function renderCodeBlock(codeContent) {
            const language = codeContent.language || 'text';
            const content = codeContent.content || '';

            return `
                <div class="node-code">
                    <div class="code-header">
                        <span class="code-language">${language.toUpperCase()}</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <pre class="language-${language}" tabindex="0"><code class="language-${language} prism-highlighted">${escapeHtml(content)}</code></pre>
                </div>
            `;
        }

        function renderTaskPromptBlock(taskPrompt) {
            return `
                <div class="node-task-prompt">
                    <div class="task-prompt-header">
                        <span class="task-prompt-label">ü§ñ Task Prompt for LLM</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <div class="task-prompt-content">${escapeHtml(taskPrompt)}</div>
                </div>
            `;
        }

        function renderCliCommandBlock(cliCommand) {
            return `
                <div class="node-cli-command">
                    <div class="cli-command-header">
                        <span class="cli-command-label">‚ö° CLI Commands</span>
                        <button class="copy-btn">Copy</button>
                    </div>
                    <div class="cli-command-content">${escapeHtml(cliCommand)}</div>
                </div>
            `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getNodeBackground(priority, status) {
            // This returns a CSS custom property value
            return 'rgba(0, 0, 0, 0)'; // Transparent by default, actual colors defined in CSS
        }

        function getStatusIcon(status) {
            switch (status) {
                case 'completed': return '‚úÖ';
                case 'in-progress': return 'üü°';
                case 'pending':
                default: return 'üî≤';
            }
        }

        // Progress tracking functions
        function updateProgress() {
            const stats = calculateProgress();

            const percentageEl = document.getElementById('progressPercentage');
            const progressBarEl = document.getElementById('progressBar');
            const completedCountEl = document.getElementById('completedCount');
            const inProgressCountEl = document.getElementById('inProgressCount');
            const pendingCountEl = document.getElementById('pendingCount');
            const totalCountEl = document.getElementById('totalCount');

            const percentage = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;

            if (percentageEl) {
                percentageEl.textContent = `${percentage}%`;
                percentageEl.style.color = percentage === 100 ? 'var(--color-success)' : 'var(--color-primary)';
            }

            if (progressBarEl) {
                progressBarEl.style.width = `${percentage}%`;
                progressBarEl.className = percentage === 100 ? 'progress-bar completed' : 'progress-bar';
            }

            if (completedCountEl) completedCountEl.textContent = stats.completed;
            if (inProgressCountEl) inProgressCountEl.textContent = stats.inProgress;
            if (pendingCountEl) pendingCountEl.textContent = stats.pending;
            if (totalCountEl) totalCountEl.textContent = stats.total;
        }

        function calculateProgress() {
            const nodes = document.querySelectorAll('.node');
            let completed = 0;
            let inProgress = 0;
            let pending = 0;

            nodes.forEach(node => {
                const status = node.dataset.status;
                switch (status) {
                    case 'completed': completed++; break;
                    case 'in-progress': inProgress++; break;
                    case 'pending':
                    default: pending++; break;
                }
            });

            return {
                completed,
                inProgress,
                pending,
                total: completed + inProgress + pending
            };
        }

        // Node interaction functions
        function toggleNodeStatus(node) {
            const currentStatus = node.dataset.status;
            let newStatus;

            switch (currentStatus) {
                case 'pending': newStatus = 'in-progress'; break;
                case 'in-progress': newStatus = 'completed'; break;
                case 'completed': newStatus = 'pending'; break;
                default: newStatus = 'pending';
            }

            updateNodeStatus(node, newStatus);
        }

        function updateNodeStatus(node, newStatus) {
            const oldStatus = node.dataset.status;

            node.dataset.status = newStatus;
            node.className = node.className.replace(/status-\w+/, `status-${newStatus}`);

            // Update status icon
            const statusIcon = node.querySelector('.icon-status');
            if (statusIcon) {
                statusIcon.textContent = getStatusIcon(newStatus);
            }

            // Add animation effect
            node.style.animation = 'color-flash 0.5s ease';
            setTimeout(() => {
                node.style.animation = '';
            }, 500);

            // Update progress
            updateProgress();

            // Mark as dirty for auto-save
            markDirty();

            console.log(`Updated node ${node.dataset.id}: ${oldStatus} ‚Üí ${newStatus}`);
        }

        // Global settings functions
        function applyGlobalSettings() {
            toggleComments(globalCommentsVisible);
            toggleDates(globalDatesVisible);
            toggleAddButtons(globalAddButtonsVisible);

            if (isFlashActive) {
                document.body.classList.add('flash-active');
            }

            if (isLinesAnimated) {
                document.body.classList.add('lines-animated');
            }
        }

        function toggleComments(show) {
            globalCommentsVisible = show;
            const comments = document.querySelectorAll('.node-comment');
            comments.forEach(comment => {
                comment.style.display = show ? 'block' : 'none';
            });

            // Update button text
            const btn = document.getElementById('toggleCommentsBtn');
            if (btn) {
                btn.querySelector('.btn-text').textContent = show ? 'Hide Comments' : 'Show Comments';
            }
        }

        function toggleDates(show) {
            globalDatesVisible = show;
            const dates = document.querySelectorAll('.node-dates');
            dates.forEach(date => {
                date.style.display = show ? 'block' : 'none';
            });

            // Update button text
            const btn = document.getElementById('toggleDatesBtn');
            if (btn) {
                btn.querySelector('.btn-text').textContent = show ? 'Hide Dates' : 'Show Dates';
            }
        }

        function toggleAddButtons(show) {
            globalAddButtonsVisible = show;
            const addIcons = document.querySelectorAll('.icon-add');
            addIcons.forEach(icon => {
                icon.style.display = show ? 'inline' : 'none';
            });

            // Update button text
            const btn = document.getElementById('toggleAddBtn');
            if (btn) {
                btn.querySelector('.btn-text').textContent = show ? 'Hide Add Buttons' : 'Show Add Buttons';
            }
        }

        function toggleAllNodes() {
            const toggles = document.querySelectorAll('.node-toggle');
            const allCollapsed = Array.from(toggles).every(toggle => toggle.textContent === '+');

            toggles.forEach(toggle => {
                const parentWrapper = toggle.closest('.node-wrapper');
                const childrenContainer = parentWrapper.nextElementSibling;

                if (childrenContainer && childrenContainer.classList.contains('node-parent')) {
                    if (allCollapsed) {
                        // Expand all
                        childrenContainer.style.display = 'block';
                        toggle.textContent = '‚Äì';
                    } else {
                        // Collapse all
                        childrenContainer.style.display = 'none';
                        toggle.textContent = '+';
                    }
                }
            });
        }

        function toggleFlash() {
            isFlashActive = !isFlashActive;

            if (isFlashActive) {
                document.body.classList.add('flash-active');
            } else {
                document.body.classList.remove('flash-active');
            }

            const btn = document.getElementById('toggleFlashBtn');
            if (btn) {
                btn.querySelector('.btn-text').textContent = isFlashActive ? 'Stop Flash' : 'Start Flash';
            }
        }

        function toggleLines() {
            isLinesAnimated = !isLinesAnimated;

            if (isLinesAnimated) {
                document.body.classList.add('lines-animated');
            } else {
                document.body.classList.remove('lines-animated');
            }

            const btn = document.getElementById('toggleAnimateLinesBtn');
            if (btn) {
                btn.querySelector('.btn-text').textContent = isLinesAnimated ? 'Stop Lines' : 'Animate Lines';
            }
        }

        function toggleView() {
            currentView = currentView === 'tree' ? 'board' : 'tree';

            const treeContainer = document.getElementById('mindMapContainer');
            const boardContainer = document.getElementById('boardContainer');
            const btn = document.getElementById('toggleViewBtn');

            if (currentView === 'board') {
                treeContainer.style.display = 'none';
                boardContainer.style.display = 'block';
                updateBoardView();
                if (btn) btn.querySelector('.btn-text').textContent = 'üå≤ Tree View';
            } else {
                treeContainer.style.display = 'block';
                boardContainer.style.display = 'none';
                if (btn) btn.querySelector('.btn-text').textContent = 'üìã Board View';
            }
        }

        function updateBoardView() {
            const stats = calculateProgress();

            // Update board title
            const boardTitle = document.getElementById('boardTitle');
            if (boardTitle && currentFile) {
                boardTitle.textContent = currentFile.replace(/\.(xml|json)$/, '');
            }

            // Update task counts in headers
            const todoCount = document.getElementById('todoCount');
            const inProgressBoardCount = document.getElementById('inProgressBoardCount');
            const doneCount = document.getElementById('doneCount');

            if (todoCount) todoCount.textContent = stats.pending;
            if (inProgressBoardCount) inProgressBoardCount.textContent = stats.inProgress;
            if (doneCount) doneCount.textContent = stats.completed;

            // Generate cards for each column
            const nodes = document.querySelectorAll('.node');
            const todoCards = document.getElementById('todoCards');
            const inProgressCards = document.getElementById('inProgressCards');
            const doneCards = document.getElementById('doneCards');

            const todoItems = [];
            const inProgressItems = [];
            const doneItems = [];

            nodes.forEach(node => {
                const status = node.dataset.status;
                const priority = node.dataset.priority;
                const title = node.querySelector('.node-title').textContent;
                const nodeId = node.dataset.id;

                const card = `
                    <div class="board-card priority-${priority}" data-id="${nodeId}" onclick="focusNodeFromBoard('${nodeId}')">
                        <div class="card-priority ${priority}"></div>
                        <div class="card-title">${title}</div>
                        <div class="card-meta">
                            <span class="card-priority-label">${priority}</span>
                        </div>
                    </div>
                `;

                switch (status) {
                    case 'pending': todoItems.push(card); break;
                    case 'in-progress': inProgressItems.push(card); break;
                    case 'completed': doneItems.push(card); break;
                }
            });

            if (todoCards) todoCards.innerHTML = todoItems.join('');
            if (inProgressCards) inProgressCards.innerHTML = inProgressItems.join('');
            if (doneCards) doneCards.innerHTML = doneItems.join('');
        }

        function focusNodeFromBoard(nodeId) {
            // Switch back to tree view
            currentView = 'tree';
            toggleView(); // This will switch to tree view

            // Find and highlight the node
            const targetNode = document.querySelector(`[data-id="${nodeId}"]`);
            if (targetNode) {
                targetNode.scrollIntoView({ behavior: 'smooth', block: 'center' });
                targetNode.style.animation = 'node-highlight 2s ease';
                setTimeout(() => {
                    targetNode.style.animation = '';
                }, 2000);
            }
        }

        // Save functionality
        async function saveMindMap() {
            if (!currentFile || !mindMapData) {
                console.warn('No file or data to save');
                return;
            }

            try {
                showSaveIndicator(true);

                // Build XML from current DOM state
                const xmlData = buildXMLFromDOM();

                const folderParam = currentFolder !== '.' ? `?folder=${encodeURIComponent(currentFolder)}` : '';
                const response = await fetchWithFallback(`/save-split/${currentFile}${folderParam}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename: currentFile,
                        data: xmlData,
                        folder: currentFolder
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.error) {
                    throw new Error(result.error);
                }

                isDirty = false;
                console.log('‚úÖ File saved successfully');

                showSaveIndicator(false, 'success');

            } catch (error) {
                console.error('Failed to save file:', error);
                showSaveIndicator(false, 'error');

                // Show error message to user
                const indicator = document.getElementById('saveIndicator');
                if (indicator) {
                    indicator.textContent = '‚ö†Ô∏è Save Failed';
                    indicator.className = 'save-indicator error';
                }
            }
        }

        function buildXMLFromDOM() {
            const rootNodes = document.querySelectorAll('#mindMapContainer > .node');
            const nodes = Array.from(rootNodes).map(buildNodeFromDOM);

            return `<?xml version="1.0" encoding="UTF-8"?>
<project_plan>
    ${nodes.map(node => buildNodeXML(node)).join('\n    ')}
</project_plan>`;
        }

        function buildNodeFromDOM(nodeElement) {
            const nodeId = nodeElement.dataset.id;
            const status = nodeElement.dataset.status;
            const priority = nodeElement.dataset.priority;
            const title = nodeElement.querySelector('.node-title').textContent;

            // Extract content from DOM
            const commentElement = nodeElement.querySelector('.node-comment');
            const comment = commentElement ? commentElement.textContent.trim() : '';

            // Extract dates
            const startDateElement = nodeElement.querySelector('[data-type="startDate"]');
            const endDateElement = nodeElement.querySelector('[data-type="endDate"]');
            const daysSpentElement = nodeElement.querySelector('.days-spent-value');

            const startDate = startDateElement ? startDateElement.textContent : '';
            const endDate = endDateElement ? endDateElement.textContent : '';
            const daysSpent = daysSpentElement ? parseInt(daysSpentElement.textContent) || 0 : 0;

            // Extract advanced features
            let codeContent = null;
            const codeElement = nodeElement.querySelector('.node-code pre code');
            if (codeElement) {
                const languageClass = Array.from(codeElement.classList).find(cls => cls.startsWith('language-'));
                const language = languageClass ? languageClass.replace('language-', '') : 'text';
                codeContent = {
                    language: language,
                    content: codeElement.textContent
                };
            }

            let taskPrompt = '';
            const taskPromptElement = nodeElement.querySelector('.task-prompt-content');
            if (taskPromptElement) {
                taskPrompt = taskPromptElement.textContent.trim();
            }

            let cliCommand = '';
            const cliCommandElement = nodeElement.querySelector('.cli-command-content');
            if (cliCommandElement) {
                cliCommand = cliCommandElement.textContent.trim();
            }

            // Extract children
            const childrenContainer = nodeElement.querySelector('.node-parent');
            const children = [];
            if (childrenContainer) {
                const childNodes = childrenContainer.children;
                for (let child of childNodes) {
                    if (child.classList.contains('node')) {
                        children.push(buildNodeFromDOM(child));
                    }
                }
            }

            return {
                id: nodeId,
                title,
                status,
                priority,
                startDate,
                endDate,
                daysSpent,
                comment,
                codeContent,
                taskPrompt,
                cliCommand,
                children
            };
        }

        function buildNodeXML(nodeData) {
            let xml = `<node id="${nodeData.id}" title="${escapeXmlAttribute(nodeData.title)}" status="${nodeData.status}" priority="${nodeData.priority}"`;

            if (nodeData.startDate) xml += ` startDate="${nodeData.startDate}"`;
            if (nodeData.endDate) xml += ` endDate="${nodeData.endDate}"`;
            if (nodeData.daysSpent > 0) xml += ` daysSpent="${nodeData.daysSpent}"`;

            xml += '>';

            // Add comment if present
            if (nodeData.comment) {
                xml += `\n        <comment>${escapeXmlContent(nodeData.comment)}</comment>`;
            }

            // Add code if present
            if (nodeData.codeContent && nodeData.codeContent.content) {
                xml += `\n        <code language="${nodeData.codeContent.language}"><![CDATA[${nodeData.codeContent.content}]]></code>`;
            }

            // Add task prompt if present
            if (nodeData.taskPrompt) {
                xml += `\n        <taskPromptForLlm><![CDATA[${nodeData.taskPrompt}]]></taskPromptForLlm>`;
            }

            // Add CLI command if present
            if (nodeData.cliCommand) {
                xml += `\n        <cliCommand><![CDATA[${nodeData.cliCommand}]]></cliCommand>`;
            }

            // Add children
            if (nodeData.children && nodeData.children.length > 0) {
                xml += '\n' + nodeData.children.map(child =>
                    '        ' + buildNodeXML(child).replace(/\n/g, '\n        ')
                ).join('\n');
            }

            xml += '\n    </node>';
            return xml;
        }

        function escapeXmlAttribute(text) {
            return text.replace(/[&<>"']/g, char => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        }

        function escapeXmlContent(text) {
            return text.replace(/[&<>]/g, char => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    default: return char;
                }
            });
        }

        function showSaveIndicator(saving, status = null) {
            const indicator = document.getElementById('saveIndicator');
            if (!indicator) return;

            if (saving) {
                indicator.textContent = 'üíæ Saving...';
                indicator.className = 'save-indicator saving';
                indicator.style.display = 'block';
            } else if (status === 'success') {
                indicator.textContent = '‚úÖ Saved';
                indicator.className = 'save-indicator success';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            } else if (status === 'error') {
                indicator.textContent = '‚ùå Save Failed';
                indicator.className = 'save-indicator error';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            } else {
                indicator.style.display = 'none';
            }
        }

        // Event handlers
        document.addEventListener('DOMContentLoaded', init);

        // File list events
        document.addEventListener('click', function(event) {
            const target = event.target;

            // File item clicks
            if (target.closest('.file-item')) {
                const fileItem = target.closest('.file-item');
                const filename = fileItem.dataset.file;
                const folder = fileItem.dataset.folder || currentFolder;
                loadFile(filename, folder);
                return;
            }

            // Folder item clicks
            if (target.closest('.folder-item')) {
                const folderItem = target.closest('.folder-item');
                const folder = folderItem.dataset.folder;
                changeFolder(folder);
                return;
            }

            // Node interaction events
            if (target.classList.contains('node-toggle')) {
                const parentWrapper = target.closest('.node-wrapper');
                const childrenContainer = parentWrapper.nextElementSibling;

                if (childrenContainer && childrenContainer.classList.contains('node-parent')) {
                    const isCollapsed = target.textContent === '+';

                    if (isCollapsed) {
                        childrenContainer.style.display = 'block';
                        target.textContent = '‚Äì';

                        // Expand all descendant nodes that were previously expanded
                        const descendantParents = childrenContainer.querySelectorAll('.node-parent');
                        const descendantToggles = childrenContainer.querySelectorAll('.node-toggle');
                        descendantParents.forEach((parent, index) => {
                            if (parent.dataset.wasExpanded === 'true') {
                                parent.style.display = 'block';
                                if (descendantToggles[index]) {
                                    descendantToggles[index].textContent = '‚Äì';
                                }
                            }
                        });
                    } else {
                        // Store expanded state of descendants before collapsing
                        const descendantParents = childrenContainer.querySelectorAll('.node-parent');
                        descendantParents.forEach(parent => {
                            parent.dataset.wasExpanded = parent.style.display !== 'none' ? 'true' : 'false';
                        });

                        childrenContainer.style.display = 'none';
                        target.textContent = '+';
                    }
                }
                return;
            }

            // Status cycling
            if (target.classList.contains('icon-status')) {
                const node = target.closest('.node');
                if (node) {
                    toggleNodeStatus(node);
                }
                return;
            }

            // Comment toggling
            if (target.classList.contains('icon-comment')) {
                const wrapper = target.closest('.node-wrapper');
                const comment = wrapper.querySelector('.node-comment');
                if (comment) {
                    const isVisible = comment.style.display !== 'none';
                    comment.style.display = isVisible ? 'none' : 'block';
                }
                return;
            }

            // Date toggling
            if (target.classList.contains('icon-date')) {
                const wrapper = target.closest('.node-wrapper');
                const dates = wrapper.querySelector('.node-dates');
                if (dates) {
                    const isVisible = dates.style.display !== 'none';
                    dates.style.display = isVisible ? 'none' : 'block';
                }
                return;
            }

            // Code toggling
            if (target.classList.contains('icon-code')) {
                const wrapper = target.closest('.node-wrapper');
                const codeBlock = wrapper.querySelector('.node-code');
                if (codeBlock) {
                    const isVisible = codeBlock.style.display !== 'none';
                    codeBlock.style.display = isVisible ? 'none' : 'block';
                }
                return;
            }

            // Task prompt toggling
            if (target.classList.contains('icon-task')) {
                const wrapper = target.closest('.node-wrapper');
                const taskBlock = wrapper.querySelector('.node-task-prompt');
                if (taskBlock) {
                    const isVisible = taskBlock.style.display !== 'none';
                    taskBlock.style.display = isVisible ? 'none' : 'block';
                }
                return;
            }

            // CLI command toggling
            if (target.classList.contains('icon-cli')) {
                const wrapper = target.closest('.node-wrapper');
                const cliBlock = wrapper.querySelector('.node-cli-command');
                if (cliBlock) {
                    const isVisible = cliBlock.style.display !== 'none';
                    cliBlock.style.display = isVisible ? 'none' : 'block';
                }
                return;
            }

            // Days spent controls
            if (target.classList.contains('days-spent-btn')) {
                const valueSpan = target.parentElement.querySelector('.days-spent-value');
                const currentValue = parseInt(valueSpan.textContent) || 0;

                if (target.classList.contains('plus')) {
                    valueSpan.textContent = currentValue + 1;
                } else if (target.classList.contains('minus') && currentValue > 0) {
                    valueSpan.textContent = currentValue - 1;
                }

                markDirty();
                return;
            }

            // Copy buttons
            if (target.classList.contains('copy-btn')) {
                const codeBlock = target.closest('.node-code, .node-task-prompt, .node-cli-command');
                let textToCopy = '';

                if (codeBlock.classList.contains('node-code')) {
                    const code = codeBlock.querySelector('code');
                    textToCopy = code ? code.textContent : '';
                } else if (codeBlock.classList.contains('node-task-prompt')) {
                    const content = codeBlock.querySelector('.task-prompt-content');
                    textToCopy = content ? content.textContent : '';
                } else if (codeBlock.classList.contains('node-cli-command')) {
                    const content = codeBlock.querySelector('.cli-command-content');
                    textToCopy = content ? content.textContent : '';
                }

                navigator.clipboard.writeText(textToCopy).then(() => {
                    target.textContent = 'Copied!';
                    setTimeout(() => {
                        target.textContent = 'Copy';
                    }, 1000);
                });
                return;
            }
        });

        // Control button events
        document.getElementById('saveBtn')?.addEventListener('click', saveMindMap);

        document.getElementById('toggleCommentsBtn')?.addEventListener('click', () => {
            globalCommentsVisible = !globalCommentsVisible;
            toggleComments(globalCommentsVisible);
        });

        document.getElementById('toggleDatesBtn')?.addEventListener('click', () => {
            globalDatesVisible = !globalDatesVisible;
            toggleDates(globalDatesVisible);
        });

        document.getElementById('toggleAddBtn')?.addEventListener('click', () => {
            globalAddButtonsVisible = !globalAddButtonsVisible;
            toggleAddButtons(globalAddButtonsVisible);
        });

        document.getElementById('toggleAllBtn')?.addEventListener('click', toggleAllNodes);
        document.getElementById('toggleFlashBtn')?.addEventListener('click', toggleFlash);
        document.getElementById('toggleAnimateLinesBtn')?.addEventListener('click', toggleLines);
        document.getElementById('toggleViewBtn')?.addEventListener('click', toggleView);

        // Cleanup button
        document.getElementById('cleanupBtn')?.addEventListener('click', async function() {
            if (!confirm('This will clean up and regenerate all node IDs. Continue?')) {
                return;
            }

            try {
                const response = await fetchWithFallback('/cleanup-ids', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    alert(`‚úÖ Cleanup completed!\n\nFiles cleaned: ${result.filesProcessed}\nBackup created: ${result.backupDir}`);
                    // Reload current file to see changes
                    if (currentFile) {
                        await loadFile(currentFile, currentFolder);
                    }
                } else {
                    throw new Error(result.error || 'Cleanup failed');
                }
            } catch (error) {
                console.error('Cleanup failed:', error);
                alert(`‚ùå Cleanup failed: ${error.message}`);
            }
        });

        // Export button
        document.getElementById('exportBtn')?.addEventListener('click', async function() {
            if (!currentFile || !mindMapData) {
                alert('No file loaded to export');
                return;
            }

            try {
                const xmlData = buildXMLFromDOM();
                const jsonData = convertXMLToJSON(xmlData);

                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFile.replace(/\.(xml|json)$/, '') + '_export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('‚úÖ File exported successfully');
            } catch (error) {
                console.error('Export failed:', error);
                alert(`‚ùå Export failed: ${error.message}`);
            }
        });

        function convertXMLToJSON(xmlString) {
            // This is a simplified conversion - in a real implementation,
            // you'd want to use a proper XML to JSON converter
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            function xmlNodeToJSON(xmlNode) {
                const result = {};

                // Handle attributes
                if (xmlNode.attributes) {
                    for (let attr of xmlNode.attributes) {
                        result[attr.name] = attr.value;
                    }
                }

                // Handle child nodes
                const children = [];
                for (let child of xmlNode.childNodes) {
                    if (child.nodeType === Node.ELEMENT_NODE) {
                        if (child.tagName === 'node') {
                            children.push(xmlNodeToJSON(child));
                        } else {
                            result[child.tagName] = child.textContent;
                        }
                    }
                }

                if (children.length > 0) {
                    result.children = children;
                }

                return result;
            }

            const rootNodes = xmlDoc.querySelectorAll('project_plan > node');
            const nodes = Array.from(rootNodes).map(xmlNodeToJSON);

            return JSON.stringify({ nodes }, null, 2);
        }

        // New file creation
        document.getElementById('newFileBtn')?.addEventListener('click', function() {
            const filename = prompt('Enter new file name (without extension):');
            if (filename && filename.trim()) {
                createNewFile(filename.trim() + '.xml');
            }
        });

        async function createNewFile(filename) {
            try {
                const response = await fetchWithFallback('/create-file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename: filename,
                        folder: currentFolder
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Reload file list and load the new file
                    await loadFileList(currentFolder);
                    await loadFile(filename, currentFolder);
                    console.log(`‚úÖ Created new file: ${filename}`);
                } else {
                    throw new Error(result.error || 'Failed to create file');
                }
            } catch (error) {
                console.error('Failed to create new file:', error);
                alert(`‚ùå Failed to create file: ${error.message}`);
            }
        }

        // Parent folder navigation
        document.getElementById('parentFolderBtn')?.addEventListener('click', function() {
            if (currentFolder && currentFolder !== '.') {
                const parentFolder = currentFolder.split('/').slice(0, -1).join('/') || '.';
                changeFolder(parentFolder);
            }
        });

        // Sidebar functionality
        function showProjectSelector() {
            const modal = document.createElement('div');
            modal.className = 'project-selector-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>üîÑ Switch Project</h2>
                        <button class="close-btn" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="project-list" id="modalProjectList">
                            <div class="loading">Loading projects...</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            loadProjectsForSelector();
        }

        async function loadProjectsForSelector() {
            try {
                const response = await fetch('/api/db/projects');
                const projects = await response.json();
                const listElement = document.getElementById('modalProjectList');

                if (projects.length === 0) {
                    listElement.innerHTML = '<div class="empty-message">No projects found</div>';
                    return;
                }

                listElement.innerHTML = projects.map(project => `
                    <div class="project-item" onclick="selectProject('${project.id}', '${project.name}')">
                        <div class="project-name">${project.name}</div>
                        <div class="project-info">
                            <small>Updated: ${new Date(project.updated_at).toLocaleDateString()}</small>
                            <small>Nodes: ${project.node_count || 0}</small>
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading projects:', error);
                document.getElementById('modalProjectList').innerHTML = '<div class="error">Error loading projects</div>';
            }
        }

        async function selectProject(projectId, projectName) {
            try {
                currentProject = { id: projectId, name: projectName };
                document.getElementById('currentProjectName').textContent = projectName;

                // Close modal
                document.querySelector('.project-selector-modal')?.remove();

                // Load project data
                await loadProjectFromDatabase(projectId);

                console.log(`Switched to project: ${projectName}`);
            } catch (error) {
                console.error('Error selecting project:', error);
                alert('Error switching to project');
            }
        }

        function createNewProject() {
            const projectName = prompt('Enter project name:');
            if (projectName && projectName.trim()) {
                createProject(projectName.trim());
            }
        }

        async function createProject(name) {
            try {
                const response = await fetch('/api/db/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, description: '' })
                });

                if (!response.ok) throw new Error('Failed to create project');

                const project = await response.json();
                currentProject = project;
                document.getElementById('currentProjectName').textContent = project.name;

                // Show controls and clear mind map
                document.getElementById('controls').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('mindMapContainer').innerHTML = '<div class="empty-project">Start adding nodes to your new project!</div>';

                updateDatabaseStats();
                console.log(`Created new project: ${project.name}`);
            } catch (error) {
                console.error('Error creating project:', error);
                alert('Error creating project');
            }
        }

        function searchProjects() {
            const searchTerm = prompt('Enter search term:');
            if (searchTerm && searchTerm.trim()) {
                performProjectSearch(searchTerm.trim());
            }
        }

        async function performProjectSearch(searchTerm) {
            try {
                const response = await fetch(`/api/db/projects/search?q=${encodeURIComponent(searchTerm)}`);
                const projects = await response.json();

                const modal = document.createElement('div');
                modal.className = 'project-selector-modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>üîç Search Results for "${searchTerm}"</h2>
                            <button class="close-btn" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                        </div>
                        <div class="modal-body">
                            <div class="project-list">
                                ${projects.length === 0 ?
                                    '<div class="empty-message">No projects found</div>' :
                                    projects.map(project => `
                                        <div class="project-item" onclick="selectProject('${project.id}', '${project.name}')">
                                            <div class="project-name">${project.name}</div>
                                            <div class="project-info">
                                                <small>Updated: ${new Date(project.updated_at).toLocaleDateString()}</small>
                                            </div>
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            } catch (error) {
                console.error('Error searching projects:', error);
                alert('Error searching projects');
            }
        }

        async function importJsonFile(file) {
            try {
                const text = await file.text();
                const jsonData = JSON.parse(text);

                const projectName = prompt('Enter project name for import:', file.name.replace('.json', ''));
                if (!projectName) return;

                // Create new project
                const projectResponse = await fetch('/api/db/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: projectName, description: `Imported from ${file.name}` })
                });

                if (!projectResponse.ok) throw new Error('Failed to create project');

                const project = await projectResponse.json();

                // Import nodes
                console.log('üîç JSON Data structure:', Object.keys(jsonData));
                const nodesToImport = jsonData.nodes || jsonData;
                console.log('üìä Nodes to import:', nodesToImport);
                await importNodesRecursively(project.id, nodesToImport, null);

                // Switch to new project
                await selectProject(project.id, project.name);

                alert(`Successfully imported project: ${projectName}`);

            } catch (error) {
                console.error('Error importing JSON:', error);
                alert('Error importing JSON file: ' + error.message);
            }
        }

        async function importNodesRecursively(projectId, nodeData, parentId) {
            console.log('üîç DEBUG importNodesRecursively called with:', {
                projectId,
                nodeDataType: typeof nodeData,
                nodeDataKeys: nodeData ? Object.keys(nodeData) : 'null',
                nodeTitle: nodeData ? nodeData.title : 'no title',
                parentId
            });

            if (!nodeData) return;

            // Handle array of nodes
            if (Array.isArray(nodeData)) {
                console.log('üìä Processing array of nodes, length:', nodeData.length);
                for (const node of nodeData) {
                    await importNodesRecursively(projectId, node, parentId);
                }
                return;
            }

            // Prepare node data with all supported fields
            const nodePayload = {
                project_id: projectId,
                parent_id: parentId,
                title: nodeData.title || 'Untitled',
                content: nodeData.comment || '',  // Database uses 'content', JSON uses 'comment'
                priority: nodeData.priority || 'medium',
                status: nodeData.status || 'pending',
                start_date: nodeData.startDate || null,
                end_date: nodeData.endDate || null,
                days_spent: nodeData.daysSpent || 0
            };

            console.log('üöÄ About to create node with payload:', nodePayload);

            // Add code block if present
            if (nodeData.code && nodeData.code.language && nodeData.code.content) {
                nodePayload.code_language = nodeData.code.language;
                nodePayload.code_content = nodeData.code.content;
            }

            // Add LLM prompt if present
            if (nodeData.taskPromptForLlm) {
                nodePayload.task_prompt = nodeData.taskPromptForLlm;
            }

            // Add CLI command if present
            if (nodeData.cliCommand) {
                nodePayload.cli_command = nodeData.cliCommand;
            }

            // Create single node
            const nodeResponse = await fetch('/api/db/nodes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(nodePayload)
            });

            if (!nodeResponse.ok) {
                const errorText = await nodeResponse.text();
                throw new Error(`Failed to create node: ${errorText}`);
            }

            const newNode = await nodeResponse.json();

            // Import children if they exist
            if (nodeData.children && Array.isArray(nodeData.children)) {
                for (const child of nodeData.children) {
                    await importNodesRecursively(projectId, child, newNode.id);
                }
            }
        }

        async function loadProjectFromDatabase(projectId) {
            try {
                console.log(`Loading project from database: ${projectId}`);

                // Fetch project details
                const projectResponse = await fetch(`/api/db/projects/${projectId}`);
                if (!projectResponse.ok) throw new Error('Failed to load project');

                const project = await projectResponse.json();

                // Fetch project nodes
                const nodesResponse = await fetch(`/api/db/projects/${projectId}/nodes`);
                if (!nodesResponse.ok) throw new Error('Failed to load project nodes');

                const nodes = await nodesResponse.json();

                // Build hierarchical structure
                const rootNodes = nodes.filter(node => !node.parent_id);
                const nodeMap = {};

                // Create node map for quick lookup
                nodes.forEach(node => {
                    nodeMap[node.id] = {
                        ...node,
                        children: []
                    };
                });

                // Build hierarchy
                nodes.forEach(node => {
                    if (node.parent_id && nodeMap[node.parent_id]) {
                        nodeMap[node.parent_id].children.push(nodeMap[node.id]);
                    }
                });

                // Convert to expected format
                const mindMapData = {
                    nodes: rootNodes.map(node => convertDbNodeToMindMapFormat(nodeMap[node.id]))
                };

                // Show controls and render
                document.getElementById('controls').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'block';

                // Render the mind map
                renderMindMap(mindMapData);

                // Update progress
                updateProgress();
                updateDatabaseStats();

                console.log(`Successfully loaded project: ${project.name}`);

            } catch (error) {
                console.error('Error loading project from database:', error);
                throw error;
            }
        }

        function convertDbNodeToMindMapFormat(dbNode) {
            const mindMapNode = {
                id: dbNode.id,
                title: dbNode.title || 'Untitled',
                priority: dbNode.priority || 'medium',
                status: dbNode.status || 'pending',
                comment: dbNode.content || '',  // Database uses 'content', mind map uses 'comment'
                startDate: dbNode.start_date || '',
                endDate: dbNode.end_date || '',
                daysSpent: dbNode.days_spent || 0,
                children: dbNode.children.map(child => convertDbNodeToMindMapFormat(child))
            };

            // Add optional fields if they exist
            if (dbNode.code_language && dbNode.code_content) {
                mindMapNode.code = {
                    language: dbNode.code_language,
                    content: dbNode.code_content
                };
            }

            if (dbNode.task_prompt) {
                mindMapNode.taskPromptForLlm = dbNode.task_prompt;
            }

            if (dbNode.cli_command) {
                mindMapNode.cliCommand = dbNode.cli_command;
            }

            return mindMapNode;
        }

        async function updateDatabaseStats() {
            try {
                // Fetch database stats from the server
                const response = await fetch('/api/db/stats');
                if (!response.ok) throw new Error('Failed to fetch database stats');

                const stats = await response.json();

                // Update the UI elements
                const projectCountElement = document.getElementById('projectCount');
                const nodeCountElement = document.getElementById('nodeCount');
                const dbSizeElement = document.getElementById('dbSize');

                if (projectCountElement) {
                    projectCountElement.textContent = stats.projects || 0;
                }

                if (nodeCountElement) {
                    nodeCountElement.textContent = stats.nodes || 0;
                }

                if (dbSizeElement) {
                    const sizeInKB = Math.round((stats.databaseSize || 0) / 1024);
                    dbSizeElement.textContent = `${sizeInKB} KB`;
                }

                console.log('Database stats updated:', stats);

            } catch (error) {
                console.error('Error updating database stats:', error);
                // Set fallback values instead of failing
                const projectCountElement = document.getElementById('projectCount');
                const nodeCountElement = document.getElementById('nodeCount');
                const dbSizeElement = document.getElementById('dbSize');

                if (projectCountElement) projectCountElement.textContent = '?';
                if (nodeCountElement) nodeCountElement.textContent = '?';
                if (dbSizeElement) dbSizeElement.textContent = '? KB';
            }
        }

        // Sidebar toggle
        document.getElementById('sidebarToggle')?.addEventListener('click', function() {
            const sidebar = document.querySelector('.sidebar');
            const mainContent = document.querySelector('.main-content');
            const isCollapsed = sidebar.classList.contains('collapsed');

            if (isCollapsed) {
                sidebar.classList.remove('collapsed');
                mainContent.classList.remove('expanded');
                this.textContent = '‚Äπ';
            } else {
                sidebar.classList.add('collapsed');
                mainContent.classList.add('expanded');
                this.textContent = '‚Ä∫';
            }
        });

        // Sidebar button event listeners
        document.getElementById('switchProjectBtn')?.addEventListener('click', function() {
            showProjectSelector();
        });

        document.getElementById('newProjectBtn')?.addEventListener('click', function() {
            createNewProject();
        });

        document.getElementById('importJsonBtn')?.addEventListener('click', function() {
            document.getElementById('jsonFileInput').click();
        });

        document.getElementById('searchProjectsBtn')?.addEventListener('click', function() {
            searchProjects();
        });

        // JSON file import handler
        document.getElementById('jsonFileInput')?.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                importJsonFile(file);
                this.value = ''; // Clear file input
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Ctrl/Cmd + S to save
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault();
                saveMindMap();
                return;
            }

            // Ctrl/Cmd + N to create new file
            if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
                event.preventDefault();
                document.getElementById('newFileBtn')?.click();
                return;
            }

            // Escape to close any open modals or focus
            if (event.key === 'Escape') {
                // Could be used to close modals, context menus, etc.
                const contextMenu = document.getElementById('contextMenu');
                if (contextMenu && contextMenu.style.display === 'block') {
                    contextMenu.style.display = 'none';
                }
                return;
            }
        });

        // Make titles editable
        document.addEventListener('dblclick', function(event) {
            if (event.target.classList.contains('node-title')) {
                makeEditable(event.target);
            }
        });

        function makeEditable(element) {
            const originalText = element.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalText;
            input.className = 'node-title-edit';

            input.addEventListener('blur', function() {
                finishEditing(element, input);
            });

            input.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    finishEditing(element, input);
                } else if (event.key === 'Escape') {
                    element.textContent = originalText;
                    element.style.display = 'inline';
                    input.remove();
                }
            });

            element.style.display = 'none';
            element.parentNode.insertBefore(input, element.nextSibling);
            input.focus();
            input.select();
        }

        function finishEditing(element, input) {
            const newText = input.value.trim();
            if (newText && newText !== element.textContent) {
                element.textContent = newText;
                markDirty();
            }
            element.style.display = 'inline';
            input.remove();
        }

        // Make comments editable
        document.addEventListener('dblclick', function(event) {
            if (event.target.classList.contains('node-comment')) {
                makeCommentEditable(event.target);
            }
        });

        function makeCommentEditable(element) {
            const originalText = element.textContent;
            const textarea = document.createElement('textarea');
            textarea.value = originalText;
            textarea.className = 'node-comment-edit';
            textarea.rows = Math.max(3, originalText.split('\n').length);

            textarea.addEventListener('blur', function() {
                finishCommentEditing(element, textarea);
            });

            textarea.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    element.textContent = originalText;
                    element.style.display = 'block';
                    textarea.remove();
                }
                // Allow Enter for new lines, Ctrl+Enter to finish
                if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
                    finishCommentEditing(element, textarea);
                }
            });

            element.style.display = 'none';
            element.parentNode.insertBefore(textarea, element.nextSibling);
            textarea.focus();
            textarea.select();
        }

        function finishCommentEditing(element, textarea) {
            const newText = textarea.value.trim();
            if (newText !== element.textContent) {
                element.textContent = newText;
                markDirty();
            }
            element.style.display = 'block';
            textarea.remove();
        }

        // Context menu for right-click actions
        let currentContextNode = null;

        document.addEventListener('contextmenu', function(event) {
            const node = event.target.closest('.node');
            if (node) {
                event.preventDefault();
                showContextMenu(event.clientX, event.clientY, node);
            }
        });

        function showContextMenu(x, y, node) {
            currentContextNode = node;
            const contextMenu = document.getElementById('contextMenu');

            if (contextMenu) {
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';
            }
        }

        // Hide context menu when clicking elsewhere
        document.addEventListener('click', function(event) {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu && !contextMenu.contains(event.target)) {
                contextMenu.style.display = 'none';
            }
        });

        // Context menu actions
        document.addEventListener('click', function(event) {
            if (event.target.classList.contains('context-menu-item')) {
                const action = event.target.dataset.priority;
                const contextMenu = document.getElementById('contextMenu');

                if (action && currentContextNode) {
                    // Set priority
                    const oldPriority = currentContextNode.dataset.priority;
                    currentContextNode.dataset.priority = action;
                    currentContextNode.className = currentContextNode.className.replace(/priority-\w+/, `priority-${action}`);
                    markDirty();

                    console.log(`Updated node priority: ${oldPriority} ‚Üí ${action}`);
                }

                contextMenu.style.display = 'none';
                currentContextNode = null;
            }
        });

        function deleteNode(node) {
            if (node && confirm('Are you sure you want to delete this node and all its children?')) {
                node.remove();
                updateProgress();
                markDirty();
                console.log('Node deleted');
            }
        }

        // Handle date inputs
        document.addEventListener('click', function(event) {
            if (event.target.classList.contains('date-value')) {
                makeDateEditable(event.target);
            }
        });

        function makeDateEditable(element) {
            const dateType = element.dataset.type;
            const currentValue = element.textContent;

            const input = document.createElement('input');
            input.type = 'date';
            input.value = currentValue;
            input.className = 'date-input';

            input.addEventListener('blur', function() {
                finishDateEditing(element, input);
            });

            input.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    finishDateEditing(element, input);
                } else if (event.key === 'Escape') {
                    element.style.display = 'inline';
                    input.remove();
                }
            });

            element.style.display = 'none';
            element.parentNode.insertBefore(input, element.nextSibling);
            input.focus();
        }

        function finishDateEditing(element, input) {
            const newValue = input.value;
            if (newValue !== element.textContent) {
                element.textContent = newValue;
                markDirty();
            }
            element.style.display = 'inline';
            input.remove();
        }

        // Initialize Prism.js for code highlighting
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });

        // Re-highlight code after dynamic content changes
        function highlightCode() {
            if (window.Prism) {
                Prism.highlightAll();
            }
        }

        // Call highlightCode after rendering
        const originalRenderMindMap = renderMindMap;
        renderMindMap = function(data) {
            originalRenderMindMap(data);
            setTimeout(highlightCode, 100);
        };
    </script>

</body>
</html>
